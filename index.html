<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>极昼博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端、web、js、html">
<meta property="og:type" content="website">
<meta property="og:title" content="极昼博客">
<meta property="og:url" content="http://zjzno1.github.io/index.html">
<meta property="og:site_name" content="极昼博客">
<meta property="og:description" content="前端、web、js、html">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="极昼博客">
<meta name="twitter:description" content="前端、web、js、html">
  
    <link rel="alternative" href="/atom.xml" title="极昼博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">极昼博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">追求卓越！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zjzno1.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第一篇博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2116/03/19/第一篇博客/" class="article-date">
  <time datetime="2116-03-19T10:04:19.000Z" itemprop="datePublished">2116-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2116/03/19/第一篇博客/">第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><h6 id="记得第一次开通技术博客是在2014年的7月，当时是在91主机上买了一年的服务器，域名加服务器总共花了700+，但是呵呵，服务真是差透了。于是转战github搭建博客，免费又方便。当时主机到期时当时写的文章没有保存下来，（心好累。。－－||）于是就在这里从开一个博客了。。之前的文章看情况有可能的话再写一遍。">记得第一次开通技术博客是在2014年的7月，当时是在91主机上买了一年的服务器，域名加服务器总共花了700+，但是呵呵，服务真是差透了。于是转战github搭建博客，免费又方便。当时主机到期时当时写的文章没有保存下来，（心好累。。－－||）于是就在这里从开一个博客了。。之前的文章看情况有可能的话再写一遍。</h6><h6 id="写本博客的目的一是积累学到的技术经验，二是进行分享。在我的技术之路上有得到很多前辈同学或者网络上不认识的人的帮助，我感觉这很温暖，也很好。交流、分享、开源是我们程序员界的优良传统，我也会继承发扬下去。">写本博客的目的一是积累学到的技术经验，二是进行分享。在我的技术之路上有得到很多前辈同学或者网络上不认识的人的帮助，我感觉这很温暖，也很好。<font style="color:red">交流、分享、开源</font>是我们程序员界的优良传统，我也会继承发扬下去。</h6><h6 id="想说的话就这么多。如果大家有什么疑问或者发现我哪里有错误，欢迎联系我^_^，qq：786833771_email：abbottzjz@gmail-com">想说的话就这么多。如果大家有什么疑问或者发现我哪里有错误，欢迎联系我^_^，qq：786833771     email：abbottzjz@gmail.com</h6><h4 id="一些其他博客">一些其他博客</h4><h6 id="Scofield_Blog"><a href="http://scofieldwyq.github.io/" target="_blank" rel="external">Scofield Blog</a></h6><h6 id="PPTing’s_Blog"><a href="http://ppting.me/" target="_blank" rel="external">PPTing’s Blog</a></h6><h6 id="markyun"><a href="http://markyun.github.io/" target="_blank" rel="external">markyun</a></h6><h6 id="廖雪峰的官方网站"><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的官方网站</a></h6><h6 id="阮一峰的博客"><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a></h6><h6 id="张鑫旭-鑫空间-鑫生活"><a href="http://www.zhangxinxu.com/" target="_blank" rel="external">张鑫旭-鑫空间-鑫生活</a></h6><h6 id="Ruby’s_Louvre(司徒正美)"><a href="http://www.cnblogs.com/rubylouvre" target="_blank" rel="external">Ruby’s Louvre(司徒正美)</a></h6><h6 id="寒冬winter的blog"><a href="http://www.cnblogs.com/winter-cn/" target="_blank" rel="external">寒冬winter的blog</a></h6><h6 id="老赵的blog"><a href="http://blog.zhaojie.me/" target="_blank" rel="external">老赵的blog</a></h6><h6 id="轮子哥不再更新的blog。。"><a href="http://www.cppblog.com/vczh" target="_blank" rel="external">轮子哥不再更新的blog。。</a></h6><h6 id="sadpig_blog"><a href="http://www.sadpig1993.com" target="_blank" rel="external">sadpig blog</a></h6><h6 id="依云’s_Blog"><a href="http://blog.lilydjwg.me/" target="_blank" rel="external">依云’s Blog</a></h6><h6 id="Parry@苏州"><a href="http://www.cnblogs.com/parry/p/issues_about_build_hybrid_app_with_ionic.html" target="_blank" rel="external">Parry@苏州</a></h6><h6 id="鱼的笔记"><a href="https://www.diefishfish.com/" target="_blank" rel="external">鱼的笔记</a></h6><h6 id="耗子哥的blog"><a href="https://coolshell.cn/" target="_blank" rel="external">耗子哥的blog</a></h6><h6 id="不给力的面条的blog"><a href="https://chi.miantiao.me" target="_blank" rel="external">不给力的面条的blog</a></h6><h6 id="lwwmaxwell的blog"><a href="http://lwwmaxwell.cn/" target="_blank" rel="external">lwwmaxwell的blog</a></h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2116/03/19/第一篇博客/" data-id="cjypybruy000mwefy24ogryqz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前言/">前言</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js中高级相关问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/js中高级相关问题/" class="article-date">
  <time datetime="2019-07-29T14:10:16.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/js中高级相关问题/">js中高级相关问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_es6相比es5新增了那些东西（es6中你都用到了什么）">1. es6相比es5新增了那些东西（es6中你都用到了什么）</h4><h4 id="2-_数组相关（从最新的开始写，那些方法改变了原数组，那些没有改变）">2. 数组相关（从最新的开始写，那些方法改变了原数组，那些没有改变）</h4><h4 id="3-_对象相关（新增了那些方法，怎么使用（平常项目中使用过那些））">3. 对象相关（新增了那些方法，怎么使用（平常项目中使用过那些））</h4><h4 id="4-_字符串相关（新增了那些方法，怎么使用（平常项目中使用过那些））">4. 字符串相关（新增了那些方法，怎么使用（平常项目中使用过那些））</h4><h4 id="5-_数组和对象相互转换，在那些情况下可以相互转换">5. 数组和对象相互转换，在那些情况下可以相互转换</h4><h4 id="6-_var，let，const_的区别，和实现原理">6. var，let，const 的区别，和实现原理</h4><h4 id="7-_实现深拷贝">7. 实现深拷贝</h4><h4 id="8-_获取页面中的全部标签，并计算个数">8. 获取页面中的全部标签，并计算个数</h4><h4 id="9-_节流和防抖，原理以及实现">9. 节流和防抖，原理以及实现</h4><h4 id="10-_call，apply，bing的原理与实现">10. call，apply，bing的原理与实现</h4><h4 id="11-_promise的相关概念及实现">11. promise的相关概念及实现</h4><h4 id="12-_箭头函数中的this，箭头函数与function的区别">12. 箭头函数中的this，箭头函数与function的区别</h4><h4 id="13-_介绍一下set，map，weakSet和weakMap的区别">13. 介绍一下set，map，weakSet和weakMap的区别</h4><h4 id="14-_settimeout_,_promise,_async/await的区别">14. settimeout , promise, async/await的区别</h4><h4 id="15-_async/await如何通过同步的方式实现异步">15. async/await如何通过同步的方式实现异步</h4><h4 id="16-_js异步解决方案的发展历程及其优缺点（amd，cmd，commonjs，es6的module）">16. js异步解决方案的发展历程及其优缺点（amd，cmd，commonjs，es6的module）</h4><h4 id="17-_for循环和foreach哪个执行效率更高，为什么">17. for循环和foreach哪个执行效率更高，为什么</h4><h4 id="18-_js判断数字，字母，中文，符号并截取16位">18. js判断数字，字母，中文，符号并截取16位</h4><h4 id="19-_手写实现js的多种继承方式">19. 手写实现js的多种继承方式</h4><h4 id="20-_使用settimeout实现setinterval，有什么优点">20. 使用settimeout实现setinterval，有什么优点</h4><h4 id="21-_js闭包的概念，闭包的使用场景，以及闭包的优缺点">21. js闭包的概念，闭包的使用场景，以及闭包的优缺点</h4><h4 id="22-_js中this的指向">22. js中this的指向</h4><h4 id="23-_js的原型链">23. js的原型链</h4><h4 id="24-_js的内存管理机制">24. js的内存管理机制</h4><h4 id="25-_js的作用域与作用域链">25. js的作用域与作用域链</h4><h4 id="26-_什么是xss和csrf，并如何防止">26. 什么是xss和csrf，并如何防止</h4><h4 id="27-_es6的class和构造函数的区别">27. es6的class和构造函数的区别</h4><h4 id="28-_js中的变量提升（和函数提升）">28. js中的变量提升（和函数提升）</h4><h4 id="29-_js的事件捕获和事件冒泡">29. js的事件捕获和事件冒泡</h4><h4 id="30-_onclick和addeventListener（第三个参数）绑定同一个元素，那个先执行，那个后执行">30. onclick和addeventListener（第三个参数）绑定同一个元素，那个先执行，那个后执行</h4><h4 id="31-_两个onclick事件，是执行第一个还是执行第二个">31. 两个onclick事件，是执行第一个还是执行第二个</h4><h4 id="32-_怎么让函数只执行一次，addeventListener的第三个参数都有哪些">32. 怎么让函数只执行一次，addeventListener的第三个参数都有哪些</h4><h4 id="33-_new一个对象的过程">33. new一个对象的过程</h4><h4 id="34-_如何判断一个js的变量是什么数据类型，有哪几种方式">34. 如何判断一个js的变量是什么数据类型，有哪几种方式</h4><p>type, instanceof, Object.prototype.toString.call();</p>
<h4 id="35-_js中如何防止一个对象被修改（删除，添加）">35. js中如何防止一个对象被修改（删除，添加）</h4><ol>
<li><p>不可扩展对象（不能再给对象添加属性和方法）</p>
<p> Object.preventExtensions(person);//设置为防拓展对象<br> Object.isExtensible(person);//用来确定对象是否可扩展。</p>
</li>
<li><p>密封对象（不能删除属性和方法）</p>
<p> Object.seal(person);//将对象密封<br> Object.isSealed(person）; // 检测对象是否被密封</p>
</li>
<li><p>冻结对象（不能修改属性和方法）</p>
<p> Object.freeze(man); // 冻结对象<br> Object.isFrozen(man); // 检测对象是否被冻结</p>
</li>
</ol>
<h4 id="36-_浏览器中的event-loop">36. 浏览器中的event-loop</h4><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<p>setTimeout的第二个参数不得小于 4 毫秒，不足会自动增加</p>
<p>同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p>
<p>微任务包括 <code>process.nextTick ，promise ，Object.observe ，MutationObserver</code><br>宏任务包括 <code>script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</code></p>
<p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p>
<p>所以正确的一次 Event loop 顺序是这样的</p>
<p>执行同步代码，这属于宏任务<br>执行栈为空，查询是否有微任务需要执行<br>执行所有微任务<br>必要的话渲染 UI<br>然后开始下一轮 Event loop，执行宏任务中的异步代码</p>
<h4 id="37-_cookie，sessionStorage，localStorage和indexDB的使用场景和优缺点">37. cookie，sessionStorage，localStorage和indexDB的使用场景和优缺点</h4><p>cookie：key/value 一般大小4k，每次访问都要传送cookie给服务器，可以设置过期时间，和域名绑定<br>localstorage：key/value 一直存储于本地硬盘（浏览器中可以删除），一般数据最大5MB（各个浏览器不一样），和域名绑定<br>sessionStorage：key/value 关闭页面或浏览器后被清除，最大5MB，和域名绑定<br>indexDB：key/object 可以存储对象，浏览器中的数据库，异步，支持事务，和域名绑定，存储空间大</p>
<p>总结：<br>LocalStorage、SessionStorage和Cookie都是通过域名进行隔离的。</p>
<p>全局存储：LocalStorage、Cookie<br>自动参与HTTP通信：Cookie<br>实现不同tab保存不同的数据：SessionStorage<br>存储大量数据：IndexDB</p>
<p>应用：登录相关可以考虑使用Cookie。</p>
<h4 id="38-_什么是函数式编程，什么是纯函数">38. 什么是函数式编程，什么是纯函数</h4><p>函数式编程：</p>
<p>纯函数定义：<br>对于相同的输入，永远得到相同的输出，它不依赖外部环境，也不会改变外部环境</p>
<h4 id="39-_如何优化递归（尾递归）">39. 如何优化递归（尾递归）</h4><p><a href="https://juejin.im/post/5acdd7486fb9a028ca53547c" target="_blank" rel="external">尾调用和尾递归</a><br>递归<br>当一个函数在内部调用自身，就可以称为一个递归</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>{
    foo();
}
</code></pre><p>这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。</p>
<p>什么是尾递归<br>当一个函数尾调用自身，就叫做尾递归。</p>
<p>例子：<br>    function foo () {<br>        return foo();<br>    }</p>
<p>好处：</p>
<h4 id="40-_函数柯里化">40. 函数柯里化</h4><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>好处：</p>
<ol>
<li>参数复用</li>
<li>提前确认</li>
<li>延迟运行</li>
</ol>
<p>curry的一些性能问题你只要知道下面四点就差不多了：</p>
<p>(1) 存取arguments对象通常要比存取命名参数要慢一点<br>(2) 一些老版本的浏览器在arguments.length的实现上是相当慢的<br>(3) 使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点<br>(4) 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</p>
<p>例子： </p>
<pre><code><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span>
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;
add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;

<span class="function">function <span class="title">add</span><span class="params">()</span> </span>{
    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span>
    var _args = Array.prototype.slice.call(arguments);

    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span>
    var _adder = function() {
        _args.push(...arguments);
        <span class="keyword">return</span> _adder;
    };

    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span>
    _adder.toString = function () {
        <span class="keyword">return</span> _args.reduce(function (a, b) {
            <span class="keyword">return</span> a + b;
        });
    }
    <span class="keyword">return</span> _adder;
}

add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)                <span class="comment">// 6</span>
add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)             <span class="comment">// 10</span>
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)          <span class="comment">// 15</span>
add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>)                <span class="comment">// 9</span>
</code></pre><h4 id="41-_函数的arguments，arguments中都有什么属性">41. 函数的arguments，arguments中都有什么属性</h4><p>作用：<br>用于储存调用函数时的所有实参（arguments数组的个数，取决于实参列表，与形参无关）<br>arguments.callee()是arguments的重要属性。表示arguments所在函数的引用地址</p>
<pre><code><span class="function">function <span class="title">name</span><span class="params">()</span> </span>{
    console.<span class="built_in">log</span>(arguments);
}
name(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
<span class="comment">// 打印出</span>
arguments {
    <span class="number">0</span>: <span class="number">1</span>
    <span class="number">1</span>: <span class="number">2</span>
    <span class="number">2</span>: <span class="number">3</span>
    callee: ƒ name()
    length: <span class="number">3</span>
    Symbol(Symbol.iterator): ƒ values()
    __proto__: Object
}
</code></pre><h4 id="42-_js的跨域通信">42. js的跨域通信</h4><p>当域名不是同一协议，同一域名或者同一端口号，则会根据浏览器的默认安全策略</p>
<h4 id="43-_js如何实现懒加载">43. js如何实现懒加载</h4><p>原理:<br>每个图片的src会有一个get请求，我们把不能看到的图片src设置为相同的图片，这些图片发一次请求即可，设置属性data-src为真正的图片路径。当图片滚动到可视区，我们就用js把data-src 赋值给 src，简单的懒加载就可以实现了。<br>代码：</p>
<pre><code><span class="keyword">let</span> imgArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);
<span class="keyword">let</span> len = imgArr.length;
<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight;
    <span class="built_in">console</span>.log(<span class="string">"seeHeight ="</span>+seeHeight);
    <span class="keyword">let</span> scrollTop =  <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;
    <span class="built_in">console</span>.log(<span class="string">"scrollTop ="</span>+scrollTop);
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++){
        <span class="built_in">console</span>.log(imgArr[i].offsetTop);
        <span class="keyword">if</span>(imgArr[i].offsetTop &lt; seeHeight + scrollTop){
                <span class="keyword">if</span>(imgArr[i].getAttribute(<span class="string">'src'</span>)==<span class="string">'timg.jpg'</span>){
                    imgArr[i].src = imgArr[i].getAttribute(<span class="string">'data-src'</span>);
                }
        }
    }
}
</code></pre><p>优化：<br>1.在初始条件下，应该有图片显示，只要在加载完毕之后滚动之前执行图片的加载即可</p>
<p>2.函数节流，但我们在高频度的滚动时，每隔一段事件开始图片的渲染。实现原理是 加入一个开关变量, 控制每隔固定的一段时间,函数才可能被触发</p>
<p>优化后代码：</p>
<pre><code><span class="keyword">let</span> imgArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);
<span class="keyword">let</span> len = imgArr.length;
<span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">//记录加载图片的位置，避免从第一张开始加载</span>
<span class="keyword">let</span> canrun = <span class="literal">true</span>;
<span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight;
<span class="built_in">console</span>.log(<span class="string">"seeHeight ="</span>+seeHeight);

lazyLoad();
<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">if</span>(!canrun){
        <span class="keyword">return</span> ;
    }
    canrun = <span class="literal">false</span>;
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'*****'</span>);
        lazyLoad();
        canrun= <span class="literal">true</span>;
    },<span class="number">1000</span>);

}

<span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>) </span>{
    <span class="keyword">let</span> scrollTop =  <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;
    <span class="built_in">console</span>.log(<span class="string">"scrollTop ="</span>+scrollTop);
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++){
        <span class="built_in">console</span>.log(imgArr[i].offsetTop);
        <span class="keyword">if</span>(imgArr[i].offsetTop &lt; seeHeight + scrollTop){
            <span class="keyword">if</span>(imgArr[i].getAttribute(<span class="string">'src'</span>)==<span class="string">'timg.jpg'</span>){
                imgArr[i].src = imgArr[i].getAttribute(<span class="string">'data-src'</span>);
            }
            n = i+<span class="number">1</span>;
            <span class="built_in">console</span>.log(<span class="string">"n="</span>+n);
        }
    }
}
</code></pre><h4 id="44-_js对象转化为字符串的步骤（存疑）">44. js对象转化为字符串的步骤（存疑）</h4><p>首先调用toString方法，只有当toString不返回一个原始值的时候，才会调用valueOf()。toString方法但是基本上所有对象都返回字符串。所以对象到字符串形式的转换基本都是使用toString方法。<br>俩个方法都不返回原始值时，会抛出错误。</p>
<h4 id="45-_什么是防御式编程">45. 什么是防御式编程</h4><p>主要思想<br>子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。</p>
<h4 id="46-_有没有写过npm包，怎么设计的，用什么模块化方式（commonjs，es6的module，ump等）">46. 有没有写过npm包，怎么设计的，用什么模块化方式（commonjs，es6的module，ump等）</h4><h4 id="47-_js中有几种方法定义函数">47. js中有几种方法定义函数</h4><p>1、使用function关键字定义函数 – 具有优先级，优先将function关键字定义的函数优先执行</p>
<p>　　function  functionName(arg0, arg1 ,…, argN){<br>　　　　　　statements<br>　　}<br>　　函数的调用：functionName()</p>
<p>2、使用函数表达式的形式定义函数（即将匿名函数复制给变量）</p>
<p> 　　var  variable = function(arg0, arg1 ,…, argN){<br>　　　　statements<br>　　 }<br>　　console.log(typeof  variable);     //function<br>　　函数调用：variable();</p>
<p>3、使用new Function构造函数定义函数</p>
<p>　　var  variable = new Function(‘name’,’alert(“hello,”+name)’);      //最末尾的是函数体，其前面的都是参数<br>　　console.log(typeof  variable);     //function<br>　　函数调用：variable(‘world’);</p>
<p>注意：</p>
<p>（1）使用fucntion关键字定义的函数，函数一旦声明，允许任意调用（在函数定义前、函数定义后、函数内部，可以在任意位置调用）<br>（2）使用函数表达式、new Function构造函数定义的函数，不能在函数定义前使用</p>
<h4 id="48-_focus/blur与focusin/focusout的区别与联系">48. focus/blur与focusin/focusout的区别与联系</h4><p>focus/blur不冒泡，focusin/focusout冒泡<br>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</p>
<h4 id="49-_用js实现千位分隔符">49. 用js实现千位分隔符</h4><pre><code>function <span class="keyword">format</span> (num) {
    <span class="keyword">var</span> <span class="keyword">reg</span>=/\<span class="keyword">d</span>{1,3}(?=(\<span class="keyword">d</span>{3})+$)/<span class="keyword">g</span>; 
    <span class="keyword">return</span> (num + '').<span class="keyword">replace</span>(<span class="keyword">reg</span>, '$&amp;,');
}
</code></pre><p>正则表达式 \d{1,3}(?=(\d{3})+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。</p>
<p>?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。</p>
<p> $&amp; 表示与正则表达式相匹配的内容，具体的使用可以查看字符串replace()方法的</p>
<h4 id="50-_ie和dom事件流区别">50. ie和dom事件流区别</h4><ol>
<li>事件流的区别 </li>
</ol>
<p>IE采用冒泡型事件 Netscape使用捕获型事件 DOM使用先捕获后冒泡型事件<br>示例： </p>
<p>复制代码代码如下:</p>
<pre><code><span class="tag">&lt;<span class="title">body</span>&gt;</span> 
<span class="tag">&lt;<span class="title">div</span>&gt;</span> 
<span class="tag">&lt;<span class="title">button</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="title">button</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">div</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">body</span>&gt;</span> 
</code></pre><p>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) </p>
<p>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流) </p>
<p>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡) </p>
<ol>
<li>事件侦听函数的区别 </li>
</ol>
<p>IE使用: </p>
<pre><code><span class="attr_selector">[Object]</span><span class="class">.attachEvent</span>(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//绑定函数 </span>
<span class="attr_selector">[Object]</span><span class="class">.detachEvent</span>(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//移除绑定 </span>
</code></pre><p>DOM使用： </p>
<pre><code><span class="attr_selector">[Object]</span><span class="class">.addEventListener</span>(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//绑定函数 </span>
<span class="attr_selector">[Object]</span><span class="class">.removeEventListener</span>(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//移除绑定 </span>
</code></pre><p>bCapture参数用于设置事件绑定的阶段，true为捕获阶段，false为冒泡阶段。</p>
<h4 id="51-_js怎么实现精确倒计时">51. js怎么实现精确倒计时</h4><h4 id="52-_js的数组降纬">52. js的数组降纬</h4><ol>
<li><p>使用flat</p>
<p> [1, [2, [3]]].flat(Infinity) // 参数可以是数字，可以拉平传入数字的n+1层，不写默认两层，Infinity默认全部拉平</p>
</li>
<li><p>flatMap() 只能拉平二维数组</p>
</li>
<li><p>使用递归</p>
<p> let newArr = [];<br> function flatArr (arr) {</p>
<pre><code>for<span class="list">(<span class="keyword">let</span> i=0<span class="comment">; i&lt;arr.length; i++) {</span>
    if<span class="list">(<span class="keyword">arr</span>[i] instanceof Array)</span> {
       flatArr<span class="list">(<span class="keyword">arr</span>[i])</span><span class="comment">;</span>
    }else {
        newArr.push<span class="list">(<span class="keyword">arr</span>[i])</span><span class="comment">;</span>
    }
}</span>
</code></pre><p> }</p>
</li>
<li><p>使用reduce</p>
<p> const flattenDeep = (arr) =&gt; Array.isArray(arr)<br> ? arr.reduce( (a, b) =&gt; […a, …flattenDeep(b)] , [])<br> : [arr]<br> flattenDeep([1, [[2], [3, [4]], 5]])</p>
</li>
</ol>
<h4 id="53-_script的标签上都有什么属性">53. script的标签上都有什么属性</h4><p>type：表示编写代码使用的脚本语言的内容类型<br>src ：表示包含要执行代码的外部文件（带有src属性的元素中，不应该包含额外的js代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略 。）<br>charset：设置字符集，例如utf-8等<br>defer：表示脚本可以延迟到文档全部被解析和显示之后再执行（defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行）<br>async： 表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。（async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行）</p>
<p>defer和async的区别：<br>  有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；<br>  有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/29/js中高级相关问题/" data-id="cjypybrx50034wefy8rtwk3dj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/算法相关/" class="article-date">
  <time datetime="2019-07-23T14:47:05.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/算法相关/">算法相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_实现一个快速排序（然后怎么优化）">1. 实现一个快速排序（然后怎么优化）</h4><h4 id="2-_深度遍历（递归以及非递归）">2. 深度遍历（递归以及非递归）</h4><h4 id="3-_广度遍历（递归以及非递归）">3. 广度遍历（递归以及非递归）</h4><h4 id="4-_递归的优化（尾递归）">4. 递归的优化（尾递归）</h4><h4 id="5-_数组的排序，去重">5. 数组的排序，去重</h4><h4 id="6-_实现一个js的深拷贝">6. 实现一个js的深拷贝</h4><h4 id="7-_动态规划法，0-1背包问题">7. 动态规划法，0-1背包问题</h4><h4 id="8-_红黑树，反转二叉树实现">8. 红黑树，反转二叉树实现</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/算法相关/" data-id="cjypybrur000jwefyipxjqelt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络基础相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/网络基础相关/" class="article-date">
  <time datetime="2019-07-23T14:28:55.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/网络基础相关/">网络基础相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_简述一下http1_1-1_2_3的区别">1. 简述一下http1 1.1 2 3的区别</h4><h4 id="2-_tcp三次握手，四次挥手">2. tcp三次握手，四次挥手</h4><h4 id="3-_https的实现方式（详细过程）,里面涉及到的加密算法都有哪些">3. https的实现方式（详细过程）,里面涉及到的加密算法都有哪些</h4><h4 id="4-_OSI七层模型">4. OSI七层模型</h4><h4 id="5-_DNS请求路径">5. DNS请求路径</h4><h4 id="6-_TCP/UDP的区别，怎么实现可靠UDP">6. TCP/UDP的区别，怎么实现可靠UDP</h4><h4 id="7-_web开发中会话的跟踪方法有哪些">7. web开发中会话的跟踪方法有哪些</h4><h4 id="8-_http_method">8. http method</h4><h4 id="9-_js跨域通信（跨域产生的原因，常见解决方法及原理，手动实现个jsonp）">9. js跨域通信（跨域产生的原因，常见解决方法及原理，手动实现个jsonp）</h4><h4 id="10-_http常用状态码_101，200，301，302，304，401，403，404，500，502等">10. http常用状态码 101，200，301，302，304，401，403，404，500，502等</h4><h4 id="11-_restful是什么，怎么使用">11. restful是什么，怎么使用</h4><h4 id="12-_从浏览器输入一个url，到页面完成的加载的过程（尽可能详细的描述）">12. 从浏览器输入一个url，到页面完成的加载的过程（尽可能详细的描述）</h4><h4 id="13-_正向代理，反向代理，透明代理">13. 正向代理，反向代理，透明代理</h4><h4 id="14-_跟踪web对话请求的方法">14. 跟踪web对话请求的方法</h4><h4 id="15-_请求时浏览器缓存_from_memory_cache_和_from_disk_cache_的依据是什么，哪些数据什么时候存放在_Memory_Cache_和_Disk_Cache中">15. 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/网络基础相关/" data-id="cjypybruf0009wefy0nhy7k6b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http-https/">http/https</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络相关/">网络相关</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node相关试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/node相关试题/" class="article-date">
  <time datetime="2019-07-23T14:03:27.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/node相关试题/">node相关试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_node什么时候内存溢出（泄露），怎么避免（解决）">1. node什么时候内存溢出（泄露），怎么避免（解决）</h4><p>原因：<br>在 Node 中，V8引擎有默认限制内存大小，通过 JavaScript 使用内存时只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），如果项目过于庞大，就会造成内存溢出。<br>解决方法：<br>（1）可以在Node启动的时候，传递–max-old-space-size或–max-new-space-size来调整内存大小的使用限制。</p>
<pre><code>node --<span class="built_in">max</span>-old-space-<span class="built_in">size</span>=<span class="number">1700</span> test.js <span class="comment">// 单位为MB</span>
<span class="comment">// 或者</span>
node --<span class="built_in">max</span>-<span class="keyword">new</span>-space-<span class="built_in">size</span>=<span class="number">1024</span> test.js <span class="comment">// 单位为KB</span>
</code></pre><p>上述参数在V8初始化时生效，一旦生效就不能再动态改变。如果遇到 Node 无法分配足够内存给 JavaScript 的情况，可以用这个办法来放宽V8默认的内存限制</p>
<h4 id="2-_node中间件（中间件是什么（定义），中间件原理是什么），为什么引入中间件，有没有写过或者使用过中间件，它解决了什么问题">2. node中间件（中间件是什么（定义），中间件原理是什么），为什么引入中间件，有没有写过或者使用过中间件，它解决了什么问题</h4><h5 id="中间件定义（是什么）：">中间件定义（是什么）：</h5><p>中间件就是请求req和响应res之间的一个应用，本质就是一个函数</p>
<p>详细描述：<br>请求浏览器向服务器发送一个请求后，服务器直接通过request定位属性的方式得到通过request携带过去的数据，就是用户输入的数据和浏览器本身的数据信息，这中间就一定有一个函数将这些数据分类做了处理，最后让<code>request（是不是response存疑）</code>对象调用使用，这个处理函数就是我们所所得中间插件</p>
<h5 id="中间件原理（app-use的原理）：">中间件原理（app.use的原理）：</h5><p>作用就是把我们用app.use注册的所有中间件和路由方法交给Router类来处理。</p>
<h5 id="中间件分类">中间件分类</h5><p>应用级中间件 ()<br>路由级中间件 (router.use, router.get, router.post等)<br>错误处理中间件 ()<br>内置中间件 （app.static）<br>第三方中间件 </p>
<h5 id="写过（或者使用过）什么中间件，解决了什么问题">写过（或者使用过）什么中间件，解决了什么问题</h5><p>写过也用过一些中间件，例如最常用的路由级中间件，首先根据页面url的不同，走到了不同的路由中间件中；在单页面应用中，还解决了单页面应用刷新时使用history下的rewrites进行重定向的问题。<br>再比如其他中间件，还用到过解析cookie，记录日志等中间件<br>自己也写过设置缓存的中间件等</p>
<pre><code>res.<span class="built_in">set</span>Header(<span class="string">"Expires"</span>, nowTime.<span class="keyword">to</span>UTCString());
res.<span class="built_in">set</span>Header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age="</span> + <span class="keyword">max</span>Age);
</code></pre><h4 id="3-_node的event-loop（）">3. node的event-loop（）</h4><p>Node 中的 Event loop 和浏览器中的不相同。</p>
<p>Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行</p>
<p>┌───────────────────────┐<br>┌─&gt;│        timers         │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;──connections───     │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p>
<p>timer<br>timers 阶段会执行 setTimeout 和 setInterval<br>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。<br>下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为1。<br><strong>I/O </strong><br>I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调<br>idle, prepare<br>idle, prepare 阶段内部实现<br>poll<br>poll 阶段很重要，这一阶段中，系统会做两件事情</p>
<p>执行到点的定时器<br>执行 poll 队列中的事件</p>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制<br>如果 poll 队列为空，会有两件事发生</p>
<p>如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate<br>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调</p>
<p>如果有别的定时器需要被执行，会回到 timer 阶段执行回调。<br>check<br>check 阶段执行 setImmediate<br>close callbacks<br>close callbacks 阶段执行 close 事件<br>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p>
<pre><code>setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);
}, <span class="number">0</span>);
setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);
})
<span class="regexp">//</span> 这里可能会输出 setTimeout，setImmediate
<span class="regexp">//</span> 可能也会相反的输出，这取决于性能
<span class="regexp">//</span> 因为可能进入 event <span class="keyword">loop</span> 用了不到 <span class="number">1</span> 毫秒，这时候会执行 setImmediate
<span class="regexp">//</span> 否则会执行 setTimeout
</code></pre><p>复制代码当然在这种情况下，执行顺序是相同的</p>
<pre><code>var fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)

fs.readFile(__filename, <span class="function"><span class="params">()</span> =&gt;</span> {
    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);
    }, <span class="number">0</span>);
    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> {
        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);
    });
});
<span class="regexp">//</span> 因为 readFile 的回调在 poll 中执行
<span class="regexp">//</span> 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调
<span class="regexp">//</span> 再去 timer 阶段执行 setTimeout
<span class="regexp">//</span> 所以以上输出一定是 setImmediate，setTimeout
</code></pre><p>复制代码上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。</p>
<pre><code>setTimeout(()=&gt;{
    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)

    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)
    })
}, <span class="number">0</span>)

setTimeout(()=&gt;{
    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)

    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)
    })
}, <span class="number">0</span>)

<span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span>
<span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span>
<span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span>
<span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span>
</code></pre><p>复制代码Node 中的 process.nextTick 会先于其他 microtask 执行。</p>
<pre><code>setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
<span class="built_in">console</span>.log(<span class="string">"timer1"</span>);

Promise.resolve().<span class="keyword">then</span>(function() {
    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);
});
}, <span class="number">0</span>);

process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> {
<span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);
});
<span class="regexp">//</span> nextTick, timer1, promise1
</code></pre><h4 id="4-_express和koa的对比，各自的优缺点">4. express和koa的对比，各自的优缺点</h4><ol>
<li><p>体积不同<br>Express较大而全，主要基于Connect中间件框架，功能丰富，随取随用，并且框架自身封装了大量便利的功能，比如路由、视图处理等等<br>koa体积更小，主要基于co中间件框架，框架自身并没集成太多功能，大部分功能需要用户自行require中间件去解决。</p>
</li>
<li><p>中间件不同<br>（1） 调用方式不同<br>express是使用了callback进行回调，koa使用了ES6 generator特性，co框架会把所有generator的返回封装成为Promise对象<br>koa的中间件模式与express的是不一样的，koa是洋葱型，express是直线型<code>存疑</code></p>
</li>
</ol>
<h4 id="5-_洋葱模型">5. 洋葱模型</h4><pre><code><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);
<span class="keyword">const</span> app = <span class="keyword">new</span> Koa();

<span class="comment">// logger</span>

app.use(<span class="keyword">async</span> (ctx, next) =&gt; {
    <span class="built_in">console</span>.log(<span class="number">1</span>);
    <span class="keyword">await</span> next();
    <span class="built_in">console</span>.log(<span class="number">2</span>);
    <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>);
    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${ctx.method}</span> <span class="subst">${ctx.url}</span> - <span class="subst">${rt}</span>`</span>);
});

<span class="comment">// x-response-time</span>

app.use(<span class="keyword">async</span> (ctx, next) =&gt; {
    <span class="built_in">console</span>.log(<span class="number">3</span>);
    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();
    <span class="keyword">await</span> next();
    <span class="built_in">console</span>.log(<span class="number">4</span>);
    <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;
    ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">${ms}</span>ms`</span>);
});

<span class="comment">// response</span>

app.use(<span class="keyword">async</span> ctx =&gt; {
    <span class="built_in">console</span>.log(<span class="number">5</span>);
    ctx.body = <span class="string">'Hello World'</span>;
});

app.listen(<span class="number">3000</span>);  <span class="comment">// 访问localhost:3000 得到 1 3 5 4 2</span>
</code></pre><p>koa的洋葱模型，在遇到next的时候会把当前中间件压栈，执行下一个中间件，一直到没有next或者next为空，然后在一个个按照先进后出的原则出栈</p>
<h4 id="6-_v8引擎相关原理与知识">6. v8引擎相关原理与知识</h4><h4 id="7-_有过哪些node的原生api，是怎么和php以及java系统交互的">7. 有过哪些node的原生api，是怎么和php以及java系统交互的</h4><p>fs、path、http(我们内部封装了h-request的npm包，在请求不同系统时，附带不同的参数)</p>
<h4 id="8-_node的守护进程，（node集群是怎么管理的，怎么收集日志的）">8. node的守护进程，（node集群是怎么管理的，怎么收集日志的）</h4><p>node的守护进程<br>pm2<br>node集群管理<br>上线代码会分别在线上node机器上全部上去，然后根据nginx做负载均衡，如果其中一台机器一直重启，在重启到一定次数后会终止重启，然后发邮件以及短信通知。<br>日志收集<br>从三个纬度收集日志</p>
<ol>
<li>首先用leo收集打到nginx的url，用来收集一些例如url，cookie，referrer等信息，已复现用户的操作路径</li>
<li>在编写代码时，使用try chach或者if代码块，如果走入异常情况，发送sentry记录日志</li>
<li>node代码中，在异常情况下，同时可以记录更为详细的log在node工程的同级目录下<h4 id="9-_node怎么上线（上线流程），怎么监控">9. node怎么上线（上线流程），怎么监控</h4></li>
</ol>
<h4 id="10-_npm_install后是怎么执行的">10. npm install后是怎么执行的</h4><p>首先根据package.json的dependencies和devDependencies去下载引用的包放在package.json的同级目录node_modules下。如果你没有设置npm的源，那默认到npm的官方网址下载，如果有设置其他源，例如淘宝源或者公司内部源，那就会去设置的源去下载。<br>npm install -g 下载到全局<br>npm install –save 保存到dependencies<br>npm install –save-dev 保存到devDependencies</p>
<h4 id="11-_node有哪些定时功能">11. node有哪些定时功能</h4><p>setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick</p>
<h4 id="12-_fs-watch和fs-watchFile有什么区别，怎么应用?">12.  fs.watch和fs.watchFile有什么区别，怎么应用?</h4><p>二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>
<h4 id="13-_实现一个简单的http服务器">13. 实现一个简单的http服务器</h4><pre><code>var <span class="keyword">http</span> = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment"> // 加载http模块</span>
<span class="keyword">http</span>.createServer(<span class="function"><span class="keyword">function</span>(<span class="title">req</span>, <span class="title">res</span>) {</span>
    res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>});<span class="comment"> // 200代表状态成功, 文档类型是给浏览器识别用的</span>
    res.<span class="built_in">write</span>(<span class="string">'&lt;meta charset="UTF-8"&gt; &lt;h1&gt;我是标题啊！&lt;/h1&gt; &lt;font color="red"&gt;这么原生，初级的服务器，下辈子能用着吗?!&lt;/font&gt;'</span>);<span class="comment"> // 返回给客户端的html数据</span>
    res.<span class="keyword">end</span>();<span class="comment"> // 结束输出流</span>
}).listen(<span class="number">3000</span>);<span class="comment"> // 绑定3ooo, 查看效果请访问 http://localhost:3000</span>
</code></pre><h4 id="14-_child-process相关">14. child-process相关</h4><ol>
<li>为什么需要child-process?<br>参考答案: node是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统shell命令交互，调用可执行文件，创建子进程进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的．child-process顾名思义，就是把node阻塞的工作交给子进程去做．</li>
<li>exec,execFile,spawn和fork都是做什么用的?<br>参考答案: exec可以用操作系统原生的方式执行各种命令，如管道 cat ab.txt | grep hello; execFile是执行一个文件; spawn是流式和操作系统进行交互; fork是两个node程序(javascript)之间时行交互.</li>
<li>实现一个简单的命令行交互程序?<br>参考答案: 那就用spawn吧.</li>
</ol>
<h4 id="15-_怎样充分利用多个CPU?">15. 怎样充分利用多个CPU?</h4><p>每个进程各使用一个CPU，，以此实现多核CPU的利用。Node提供了child_process模块，并且也提供了fork()方法来实现进程的复制(Node复制进程需要不小于10M的内存和不小于30ms的时间)。<br>解决方案就是Master-Worker模式（又称为主从模式），通过IPC通道实现主从进程间的通信，通信的目的是为了让不同的进程能够互相访问资源并进行协调工作</p>
<h4 id="16-_程序总是崩溃，怎样找出问题在哪里?">16. 程序总是崩溃，怎样找出问题在哪里?</h4><p>参考答案: 1) node –prof 查看哪些函数调用次数多 2) memwatch和heapdump获得内存快照进行对比，查找内存溢出</p>
<h4 id="17-_有哪些常用方法可以防止程序崩溃?">17. 有哪些常用方法可以防止程序崩溃?</h4><p>1) try-catch-finally<br>2) EventEmitter/Stream error事件处理<br>3) domain统一控制<br>4) jshint静态检查<br>5) jasmine/mocha进行单元测试</p>
<h4 id="18-_怎样调试node程序">18. 怎样调试node程序</h4><p>node –debug app.js 和node-inspector</p>
<h4 id="19-_typeScript的优点（具体举例）">19. typeScript的优点（具体举例）</h4><p>两大特性：</p>
<ol>
<li>给JavaScript加上可选的类型系统，很多事情是只有静态类型才能做的，给JavaScript加上静态类型后，就能将调试从运行期提前到编码期，诸如类型检查、越界检查这样的功能才能真正发挥作用。TypeScript的开发体验远远超过以往纯JavaScript的开发体验，无需运行程序即可修复潜在bug。</li>
<li>另一个特性是支持未来的ES 6甚至ES 7，最近的更新都与此有关。在TypeScript中，你可以直接使用ES 6的最新特性，在编译时它会自动编译到ES 3或ES 5。</li>
</ol>
<p>优点细节浏览：</p>
<ol>
<li>TS是一个应用程序级的JavaScript开发语言。</li>
<li>TS是JavaScript的超集，可以编译成纯JavaScript。</li>
<li>TS跨浏览器、跨操作系统、跨主机，开源。</li>
<li>TS始于JS，终于JS。遵循JavaScript的语法和语义，方便了无数的JavaScript开发者。</li>
<li>TS可以重用现有的JavaScript代码，调用流行的JavaScript库。</li>
<li>TS可以编译成简洁、简单的JavaScript代码，在任意浏览器、Node.js或任何兼容ES3的环境上运行。</li>
<li>TypeScript比JavaScript更具开发效率，包括：静态类型检查、基于符号的导航、语句自动完成、代码重构等。</li>
<li>TS提供了类、模块和接口，更易于构建组件。</li>
</ol>
<h4 id="20-_介绍一下对nodejs的异步IO原理，以及内部线程池相关内容">20. 介绍一下对nodejs的异步IO原理，以及内部线程池相关内容</h4><h4 id="21-_nodejs的进程维护有了解过么">21. nodejs的进程维护有了解过么</h4><h4 id="22-_nodejs的0秒重载">22. nodejs的0秒重载</h4><h4 id="23-_express运行流程与原理">23. express运行流程与原理</h4><h4 id="24-_模版引擎是怎么渲染到页面上的">24. 模版引擎是怎么渲染到页面上的</h4><h4 id="25-_express中的路由规则">25. express中的路由规则</h4><h4 id="26-_node性能优化">26. node性能优化</h4><h4 id="27-_说一下node里对Buffer数据类型的认识，对于初始化的Buffer，可以实现增加长度吗">27. 说一下node里对Buffer数据类型的认识，对于初始化的Buffer，可以实现增加长度吗</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/node相关试题/" data-id="cjypybrvw001uwefyd3gtdctz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node相关试题/">node相关试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue相关试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/vue相关试题/" class="article-date">
  <time datetime="2019-07-23T13:34:13.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/vue相关试题/">vue相关试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_vue的生命周期及相关概念（哪个周期在干什么）">1. vue的生命周期及相关概念（哪个周期在干什么）</h4><h4 id="2-_vue-model_怎么实现双向数据绑定">2. vue-model 怎么实现双向数据绑定</h4><h4 id="3-_组件之间的通信(传值)有几种实现方式">3. 组件之间的通信(传值)有几种实现方式</h4><h4 id="4-_vue和其他框架相比，有什么优缺点">4. vue和其他框架相比，有什么优缺点</h4><h4 id="5-_vue3-0（相关）和2-0比较，有什么优缺点">5. vue3.0（相关）和2.0比较，有什么优缺点</h4><h4 id="6-_vue里this的指向">6. vue里this的指向</h4><h4 id="7-_v-for的时候为什么要使用key，优缺点什么">7. v-for的时候为什么要使用key，优缺点什么</h4><h4 id="8-_vue的diff算法">8. vue的diff算法</h4><h4 id="9-_vue怎么更新的视图，视图怎么更新vue">9. vue怎么更新的视图，视图怎么更新vue</h4><h4 id="10-_vue中的on可以监听多个事件嘛">10. vue中的on可以监听多个事件嘛</h4><h4 id="11-_vuex相关，（action和mutations有什么区别）">11. vuex相关，（action和mutations有什么区别）</h4><h4 id="12-_vue-router相关（vue-router的生命周期，动态加载，传值，实现原理，全局守卫_https://router-vuejs-org/zh/_https://blog-csdn-net/yelin042/article/details/79932606）">12. vue-router相关（vue-router的生命周期，动态加载，传值，实现原理，全局守卫 <a href="https://router.vuejs.org/zh/" target="_blank" rel="external">https://router.vuejs.org/zh/</a>  <a href="https://blog.csdn.net/yelin042/article/details/79932606）" target="_blank" rel="external">https://blog.csdn.net/yelin042/article/details/79932606）</a></h4><h4 id="13-_keep-alive相关">13. keep-alive相关</h4><h4 id="14-_vue的渲染过程，vue组件的渲染过程">14. vue的渲染过程，vue组件的渲染过程</h4><h4 id="15-_vue中的data可以是个对象吗，为什么">15. vue中的data可以是个对象吗，为什么</h4><h4 id="16-_vue里的$this-nextTick();">16. vue里的$this.nextTick();</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/vue相关试题/" data-id="cjypybrvp001lwefy2mkexloq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/设计模式/" class="article-date">
  <time datetime="2019-07-23T13:33:51.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>二、结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>三、行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>1、工厂方法模式：</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p>
<p>工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，这就用到工厂方法模式。</p>
<p>创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<p>2、抽象工厂模式：</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。<br>3、单例模式：</p>
<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<p>（1）某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p>
<p>（2）省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p>
<p>（3）有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>4、建造者模式：</p>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>5、原型模式：</p>
<p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类。</p>
<p>6、适配器模式：</p>
<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<p>7、装饰器模式：</p>
<p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p>8、代理模式：</p>
<p>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。</p>
<p>9、外观模式：</p>
<p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<p>10、桥接模式：</p>
<p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样。</p>
<p>JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。</p>
<p>11、组合模式：</p>
<p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便。使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
<p>12、享元模式：</p>
<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p>13、策略模式：</p>
<p>策略模式定义了一系列算法，并将每个算法封装起来，使其可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。</p>
<p>14、模板方法模式：</p>
<p>一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。</p>
<p>15、观察者模式：<br>观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。</p>
<p>其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。</p>
<p>16、迭代子模式：</p>
<p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。</p>
<p>17、责任链模式：</p>
<p>责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。</p>
<p>18、命令模式：</p>
<p>命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开。</p>
<p>19、备忘录模式：</p>
<p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。</p>
<p>20、状态模式：</p>
<p>状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p>
<p>21、访问者模式：</p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。</p>
<p>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。</p>
<p>22、中介者模式：</p>
<p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。</p>
<p>如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。</p>
<p>23、解释器模式：</p>
<p>解释器模式一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/设计模式/" data-id="cjypybru40005wefydpvhfn6u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flex指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/flex指南/" class="article-date">
  <time datetime="2019-07-18T07:51:41.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/flex指南/">flex指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>flex,即‘弹性布局’，任何盒模型都可以用</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
</code></pre><p>行内元素也可以使用 Flex 布局</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-flex</span></span>;
}</span>
</code></pre><p>Webkit 内核的浏览器，需要加上<code>-webkit</code>（兼容ios8）</p>
<pre><code><span class="class">.box</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>; <span class="comment">/* Safari */</span>
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
</code></pre><p>flex有两条轴，分别是主轴（水平轴 main axis）和交叉轴（竖直轴 cross axis）;</p>
<h4 id="容器的属性">容器的属性</h4><p>1) flex-direction 决定主轴的方向</p>
<p>值</p>
<ul>
<li>row // 主轴为水平方向，起点在左端</li>
<li>row-reverse // 主轴为水平方向，起点在右端</li>
<li>column // 主轴为垂直方向，起点在上沿</li>
<li>column-reverse // 主轴为垂直方向，起点在下沿</li>
</ul>
<p>2) flex-warp 如果一条轴线排不下，如何换行</p>
<p>值</p>
<ul>
<li>nowrap // 不换行(默认)</li>
<li>wrap // 换行，第一行在上方</li>
<li>wrap-reverse // 换行，第一行在下方</li>
</ul>
<p>3) flex-flow 属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>
<p>值</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> &lt;flex-direction&gt; || &lt;flex-wrap&gt;</span></span>;
}</span>
</code></pre><p>4) justify-content 属性定义了项目在主轴上的对齐方式</p>
<p>值</p>
<ul>
<li>flex-start 靠左对齐</li>
<li>flex-end 靠右对齐</li>
<li>center 居中</li>
<li>space-between 均匀的间隔，（两头不留空隙）</li>
<li>space-around 均匀的间隔，两头留空隙，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<p>5) align-items 交叉轴上如何对齐</p>
<p>值</p>
<ul>
<li>flex-start 靠上对齐</li>
<li>flex-end 靠下对齐</li>
<li>center 居中</li>
<li>baseline 项目的第一行文字的基线对齐</li>
<li>stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p>6) align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>值</p>
<ul>
<li>flex-start 与交叉轴的起点对齐</li>
<li>flex-end 与交叉轴的终点对齐</li>
<li>center 与交叉轴的中点对齐</li>
<li>space-between 与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch （默认值）：轴线占满整个交叉轴。</li>
</ul>
<h4 id="项目的属性(里面的item)">项目的属性(里面的item)</h4><p>1) order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<pre><code><span class="class">.item</span> <span class="rules">{
    <span class="rule"><span class="attribute">order</span>:<span class="value"> &lt;integer&gt;</span></span>;
}</span>
</code></pre><p>2) flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<p>3) flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 （如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。）<br>4) flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小<br>5) flex 属性是flex-grow（元素水平方向在哪，越小越靠前）, flex-shrink （元素等比缩小）和 flex-basis（元素的宽度）的简写，默认值为0 1 auto。后两个属性可选。<br>6) align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/18/flex指南/" data-id="cjypybrxu003wwefy9a8vg3a1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex/">flex</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es7-es8-es9-es10新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/es7-es8-es9-es10新特性/" class="article-date">
  <time datetime="2019-07-18T01:33:10.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/es7-es8-es9-es10新特性/">es7,es8,es9,es10新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="es7的新特性：">es7的新特性：</h2><h3 id="新增特性：">新增特性：</h3><p>Array.prototype.includes()<br>**</p>
<h3 id="1)_Array-prototype-includes()">1) Array.prototype.includes()</h3><p>用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<h4 id="参数">参数</h4><p>接收两个参数</p>
<p>1.要搜索的值<br>2.搜索的开始索引</p>
<h4 id="与indexof的区别">与indexof的区别</h4><p>1.返回值不同，indexof返回是值型的，includes返回值是布尔型的<br>2.NaN的判断，如果数组中有NaN，indexof无法判断出来，但是includes可以<br>3.当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会</p>
<h3 id="2)_**_求幂运算符">2) ** 求幂运算符</h3><p>可以使用**来替代Math.pow。</p>
<pre><code><span class="number">4</span> ** <span class="number">3</span>  <span class="comment">// 64</span>
Math.<span class="built_in">pow</span>(<span class="number">4</span>,<span class="number">3</span>) <span class="comment">// 64</span>
</code></pre><p>但是，**还支持以下操作</p>
<pre><code>let n = <span class="number">4</span>;
n **= <span class="number">3</span>;
<span class="comment">// 64</span>
</code></pre><h2 id="es8_新特性">es8 新特性</h2><p>主要新功能：</p>
<h3 id="新增特性">新增特性</h3><h4 id="主要特性">主要特性</h4><p>异步函数 Async Functions<br>共享内存和Atomics</p>
<h4 id="次要特性">次要特性</h4><p>Object.values / Object.entries<br>String padding<br>Object.getOwnPropertyDescriptors()<br>函数参数列表和调用中的尾逗号</p>
<h2 id="es9_新特性">es9 新特性</h2><h3 id="新增特性-1">新增特性</h3><h4 id="主要特性-1">主要特性</h4><p>异步迭代<br>Rest/Spread 属性</p>
<h4 id="新的正则表达式功能">新的正则表达式功能</h4><p>RegExp named capture groups<br>RegExp Unicode Property Escapes<br>RegExp Lookbehind Assertions<br>s (dotAll) flag for regular expressions</p>
<h4 id="其他新功能">其他新功能</h4><p>Promise.prototype.finally()<br>模板字符串修改</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/18/es7-es8-es9-es10新特性/" data-id="cjypybry10043wefyv2g6dsp2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es/">es</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新特性/">新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js的数组与数组降纬" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/13/js的数组与数组降纬/" class="article-date">
  <time datetime="2019-07-13T09:20:47.000Z" itemprop="datePublished">2019-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/13/js的数组与数组降纬/">js的数组与数组降纬</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数组的方法</p>
<h4 id="数组降纬">数组降纬</h4><p>二位数组降纬</p>
<pre><code><span class="list">[<span class="keyword">1</span>, <span class="list">[<span class="keyword">2</span>], <span class="number">3</span>].flatMap<span class="list">(<span class="list">(<span class="keyword">v</span>)</span> =&gt; v + <span class="number">1</span>)</span>
// -&gt; <span class="list">[<span class="keyword">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span></span></span>
</code></pre><p>多维数组降纬</p>
<pre><code>const flattenDeep = <span class="function"><span class="params">(arr)</span> =&gt;</span> Array.isArray(arr)
</code></pre><p>  ? arr.reduce( (a, b) =&gt; […a, …flattenDeep(b)] , [])<br>  : [arr]</p>
<pre><code>flattenDeep([<span class="number">1</span>, [[<span class="number">2</span>], [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]])
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/13/js的数组与数组降纬/" data-id="cjypybrw30023wefy66fr46jd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IIFE/">IIFE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP/">MVP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/">MVVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app-store/">app store</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apply/">apply</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call/">call</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/">flex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gulp/">gulp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-博客/">hexo 博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-https/">http/https</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ionic/">ionic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node相关试题/">node相关试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prototype/">prototype</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三角形/">三角形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件冒泡/">事件冒泡</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件委托/">事件委托</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件捕获/">事件捕获</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件绑定/">事件绑定</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前言/">前言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型-原型链/">原型/原型链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回调函数/">回调函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化相关/">性能优化相关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/收藏/">收藏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文章/">文章</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新特性/">新特性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/柯里化/">柯里化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模型/">模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/水平竖直居中/">水平竖直居中</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深拷贝-浅拷贝/">深拷贝/浅拷贝</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/箭头函数/">箭头函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络相关/">网络相关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题（知识点）总结/">面试题（知识点）总结</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IIFE/" style="font-size: 10px;">IIFE</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/MVP/" style="font-size: 10px;">MVP</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/app-store/" style="font-size: 10px;">app store</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/call/" style="font-size: 10px;">call</a> <a href="/tags/css/" style="font-size: 17.5px;">css</a> <a href="/tags/es/" style="font-size: 10px;">es</a> <a href="/tags/es6/" style="font-size: 12.5px;">es6</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/hexo-博客/" style="font-size: 10px;">hexo 博客</a> <a href="/tags/html/" style="font-size: 12.5px;">html</a> <a href="/tags/http-https/" style="font-size: 10px;">http/https</a> <a href="/tags/ionic/" style="font-size: 10px;">ionic</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nodejs/" style="font-size: 12.5px;">nodejs</a> <a href="/tags/node相关试题/" style="font-size: 10px;">node相关试题</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/三角形/" style="font-size: 10px;">三角形</a> <a href="/tags/事件冒泡/" style="font-size: 10px;">事件冒泡</a> <a href="/tags/事件委托/" style="font-size: 10px;">事件委托</a> <a href="/tags/事件捕获/" style="font-size: 10px;">事件捕获</a> <a href="/tags/事件绑定/" style="font-size: 10px;">事件绑定</a> <a href="/tags/前言/" style="font-size: 10px;">前言</a> <a href="/tags/原型-原型链/" style="font-size: 10px;">原型/原型链</a> <a href="/tags/回调函数/" style="font-size: 10px;">回调函数</a> <a href="/tags/性能优化相关/" style="font-size: 10px;">性能优化相关</a> <a href="/tags/收藏/" style="font-size: 10px;">收藏</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a> <a href="/tags/文章/" style="font-size: 10px;">文章</a> <a href="/tags/新特性/" style="font-size: 10px;">新特性</a> <a href="/tags/柯里化/" style="font-size: 10px;">柯里化</a> <a href="/tags/模型/" style="font-size: 10px;">模型</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/水平竖直居中/" style="font-size: 10px;">水平竖直居中</a> <a href="/tags/深拷贝-浅拷贝/" style="font-size: 10px;">深拷贝/浅拷贝</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/箭头函数/" style="font-size: 10px;">箭头函数</a> <a href="/tags/网络相关/" style="font-size: 10px;">网络相关</a> <a href="/tags/规范/" style="font-size: 10px;">规范</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/面试题（知识点）总结/" style="font-size: 15px;">面试题（知识点）总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2116/03/">三月 2116</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2116/03/19/第一篇博客/">第一篇博客</a>
          </li>
        
          <li>
            <a href="/2019/07/29/js中高级相关问题/">js中高级相关问题</a>
          </li>
        
          <li>
            <a href="/2019/07/23/算法相关/">算法相关</a>
          </li>
        
          <li>
            <a href="/2019/07/23/网络基础相关/">网络基础相关</a>
          </li>
        
          <li>
            <a href="/2019/07/23/node相关试题/">node相关试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Polar_Space(zjzno1)<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>