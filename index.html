<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>极昼博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前端、web、js、html">
<meta property="og:type" content="website">
<meta property="og:title" content="极昼博客">
<meta property="og:url" content="http://zjzno1.github.io/index.html">
<meta property="og:site_name" content="极昼博客">
<meta property="og:description" content="前端、web、js、html">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="极昼博客">
<meta name="twitter:description" content="前端、web、js、html">
  
    <link rel="alternative" href="/atom.xml" title="极昼博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">极昼博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">追求卓越！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://zjzno1.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-第一篇博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2116/03/19/第一篇博客/" class="article-date">
  <time datetime="2116-03-19T10:04:19.000Z" itemprop="datePublished">2116-03-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/blog/">blog</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2116/03/19/第一篇博客/">第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><h6 id="记得第一次开通技术博客是在2014年的7月，当时是在91主机上买了一年的服务器，域名加服务器总共花了700+，但是呵呵，服务真是差透了。于是转战github搭建博客，免费又方便。当时主机到期时当时写的文章没有保存下来，（心好累。。－－||）于是就在这里从开一个博客了。。之前的文章看情况有可能的话再写一遍。">记得第一次开通技术博客是在2014年的7月，当时是在91主机上买了一年的服务器，域名加服务器总共花了700+，但是呵呵，服务真是差透了。于是转战github搭建博客，免费又方便。当时主机到期时当时写的文章没有保存下来，（心好累。。－－||）于是就在这里从开一个博客了。。之前的文章看情况有可能的话再写一遍。</h6><h6 id="写本博客的目的一是积累学到的技术经验，二是进行分享。在我的技术之路上有得到很多前辈同学或者网络上不认识的人的帮助，我感觉这很温暖，也很好。交流、分享、开源是我们程序员界的优良传统，我也会继承发扬下去。">写本博客的目的一是积累学到的技术经验，二是进行分享。在我的技术之路上有得到很多前辈同学或者网络上不认识的人的帮助，我感觉这很温暖，也很好。<font style="color:red">交流、分享、开源</font>是我们程序员界的优良传统，我也会继承发扬下去。</h6><h6 id="想说的话就这么多。如果大家有什么疑问或者发现我哪里有错误，欢迎联系我^_^，qq：786833771_email：abbottzjz@gmail-com">想说的话就这么多。如果大家有什么疑问或者发现我哪里有错误，欢迎联系我^_^，qq：786833771     email：abbottzjz@gmail.com</h6><h4 id="一些其他博客">一些其他博客</h4><h6 id="Scofield_Blog"><a href="http://scofieldwyq.github.io/" target="_blank" rel="external">Scofield Blog</a></h6><h6 id="PPTing’s_Blog"><a href="http://ppting.me/" target="_blank" rel="external">PPTing’s Blog</a></h6><h6 id="markyun"><a href="http://markyun.github.io/" target="_blank" rel="external">markyun</a></h6><h6 id="廖雪峰的官方网站"><a href="http://www.liaoxuefeng.com/" target="_blank" rel="external">廖雪峰的官方网站</a></h6><h6 id="阮一峰的博客"><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰的博客</a></h6><h6 id="张鑫旭-鑫空间-鑫生活"><a href="http://www.zhangxinxu.com/" target="_blank" rel="external">张鑫旭-鑫空间-鑫生活</a></h6><h6 id="Ruby’s_Louvre(司徒正美)"><a href="http://www.cnblogs.com/rubylouvre" target="_blank" rel="external">Ruby’s Louvre(司徒正美)</a></h6><h6 id="寒冬winter的blog"><a href="http://www.cnblogs.com/winter-cn/" target="_blank" rel="external">寒冬winter的blog</a></h6><h6 id="老赵的blog"><a href="http://blog.zhaojie.me/" target="_blank" rel="external">老赵的blog</a></h6><h6 id="轮子哥不再更新的blog。。"><a href="http://www.cppblog.com/vczh" target="_blank" rel="external">轮子哥不再更新的blog。。</a></h6><h6 id="sadpig_blog"><a href="http://www.sadpig1993.com" target="_blank" rel="external">sadpig blog</a></h6><h6 id="依云’s_Blog"><a href="http://blog.lilydjwg.me/" target="_blank" rel="external">依云’s Blog</a></h6><h6 id="Parry@苏州"><a href="http://www.cnblogs.com/parry/p/issues_about_build_hybrid_app_with_ionic.html" target="_blank" rel="external">Parry@苏州</a></h6><h6 id="鱼的笔记"><a href="https://www.diefishfish.com/" target="_blank" rel="external">鱼的笔记</a></h6><h6 id="耗子哥的blog"><a href="https://coolshell.cn/" target="_blank" rel="external">耗子哥的blog</a></h6><h6 id="不给力的面条的blog"><a href="https://chi.miantiao.me" target="_blank" rel="external">不给力的面条的blog</a></h6><h6 id="lwwmaxwell的blog"><a href="http://lwwmaxwell.cn/" target="_blank" rel="external">lwwmaxwell的blog</a></h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2116/03/19/第一篇博客/" data-id="cjz3fazz7000mp0fy31cas5jv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前言/">前言</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http缓存详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/07/http缓存详解/" class="article-date">
  <time datetime="2019-08-07T06:34:37.000Z" itemprop="datePublished">2019-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/07/http缓存详解/">http缓存详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://www.cnblogs.com/echolun/p/9419517.html" target="_blank" rel="external">http缓存详解，http缓存推荐方案</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/08/07/http缓存详解/" data-id="cjz3fb01f003lp0fyx7xsgr8l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/缓存/">缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js中高级相关问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/js中高级相关问题/" class="article-date">
  <time datetime="2019-07-29T14:10:16.000Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/js中高级相关问题/">js中高级相关问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_es6相比es5新增了那些东西（es6中你都用到了什么）">1. es6相比es5新增了那些东西（es6中你都用到了什么）</h4><p>（常用）<br>扩展运算符…([1,2,3,4])<br>Destructuring Assignment （解构赋值）<br>Arrow Functions in（箭头函数）<br>Default Parameters（默认参数）<br>Template Literals（模板对象）<br>Promises<br>块作用域和构造let和const<br>Classes （类）in ES6<br>ES6 module<br>数组和对象新增的方法和属性</p>
<pre><code><span class="comment">// 对象新增的方法</span>

<span class="comment">// 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致</span>
<span class="built_in">Object</span>.is()

<span class="comment">// Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span>
<span class="built_in">Object</span>.assign()

<span class="comment">// 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</span>
<span class="built_in">Object</span>.keys()

<span class="comment">// Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</span>
<span class="built_in">Object</span>.values()

<span class="comment">//  Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组</span>

<span class="keyword">const</span> obj = { foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> };
<span class="built_in">Object</span>.entries(obj)
<span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span>


<span class="comment">//  Object.fromEntries() 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map结构转为对象。Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。用于将一个键值对数组转为对象。该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象</span>

<span class="built_in">Object</span>.fromEntries([
  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],
  [<span class="string">'baz'</span>, <span class="number">42</span>]
])
<span class="comment">// { foo: "bar", baz: 42 }</span>

<span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(<span class="string">'foo=bar&amp;baz=qux'</span>))
<span class="comment">// { foo: "bar", baz: "qux" }</span>


<span class="comment">// 数组新增方法</span>
<span class="number">1.</span><span class="built_in">Array</span>.from()方法:<span class="built_in">JSON</span>数组格式转换
<span class="keyword">let</span> people={
    <span class="number">0</span>:<span class="string">'zhangsan'</span>, 
    <span class="string">'1'</span>:<span class="number">24</span>,     <span class="comment">//key值必须是0,1,2......可以是数字或者字符串</span>
    length:<span class="number">2</span>    <span class="comment">//必须有length这个特殊的属性</span>
};
<span class="keyword">let</span> trans=<span class="built_in">Array</span>.from(people);<span class="comment">//Array.from()方法</span>
<span class="built_in">console</span>.log(trans); <span class="comment">//['zhangsan',24]</span>
<span class="comment">// 伪数组转化为数组</span>
<span class="keyword">var</span> doms = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);
<span class="keyword">var</span> domsList = <span class="built_in">Array</span>.from(doms);


<span class="number">2.</span><span class="built_in">Array</span>.of()方法：
<span class="keyword">let</span> arr =<span class="built_in">Array</span>.of(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'zhang'</span>,<span class="string">'li'</span>);
<span class="built_in">console</span>.log(arr);  <span class="comment">//[3, 4, 5, "zhang","li"]</span>


<span class="number">3.</span>find( )实例方法:
所谓的实例方法就是并不是以<span class="built_in">Array</span>对象开始的，而是必须有一个已经存在的数组，然后使用的方法，这就是实例方法（不理解请看下边的代码）。这里的find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数：

value：表示当前查找的值。
index：表示当前查找的数组索引。
arr：表示当前数组。

<span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];
<span class="built_in">console</span>.log(arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>)</span>{
    <span class="keyword">return</span> value &gt; <span class="number">5</span>;
})) 
<span class="comment">//输出6  注意:在函数中如果找到符合条件的数组元素就return，并停止查找 ,找不到的话就 返回的unde</span>

<span class="number">4.</span> findIndex()实例方法
<span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>];
<span class="built_in">console</span>.log(arr.findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,arr</span>)</span>{
    <span class="keyword">return</span> value &gt; <span class="number">5</span>;
})) 
<span class="comment">// 结果： 5 ,如果在数组中找不到该元素 则返回  -1</span>

<span class="number">5.</span> includes() 方法 查看某个数组是否包含给定的值
参数:
第一个参数必选（待检查的给定值）
第二个参数可选，表示搜索的起始位置，默认为<span class="number">0</span>，负数表示倒数的位置

[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>, <span class="number">2</span>);     <span class="comment">// false</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span>

返回值:<span class="built_in">Boolean</span> 
注意：和indexOf的区别，indexOf进行了运算符的强比对，会导致对<span class="literal">NaN</span>误判。

[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span>

<span class="number">6.</span> fill()函数，使用指定的元素替换原数组内容，会改变原来的数组。

fill(value, start, end)

value：替换值。
start：替换起始位置（数组的下标），可以省略。
end：替换结束位置（数组的下标），
如果省略不写就默认为数组结束。有参数时为结束位置，但不替换该位置。如果结束位置大于数组的长度，那么默认也只替换到数组的实际长度结束位置。
替换的区间为 [start,end) 。
<span class="keyword">let</span> oldArr1 = [];
<span class="keyword">let</span> oldArr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="keyword">let</span> newArr1 = oldArr1.fill(<span class="number">6</span>); <span class="comment">//当为空数组时什么都不替换</span>
<span class="keyword">let</span> newArr2 = oldArr2.fill(<span class="number">6</span>);
<span class="built_in">console</span>.log(newArr1); <span class="comment">// []</span>
<span class="built_in">console</span>.log(newArr2); <span class="comment">// [6, 6, 6]</span>

<span class="number">7.</span><span class="keyword">for</span>..of数组索引:有时候开发中是需要数组的索引的，那我们可以使用下面的代码输出数组索引。

<span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];
<span class="keyword">for</span>(a <span class="keyword">of</span> arr){
    <span class="built_in">console</span>.log(a);
}

<span class="number">8.</span>copyWithin()：
选择数组的某个下标，从该位置开始复制数组元素，默认从<span class="number">0</span>开始复制。也可以指定要复制的元素范围。

arr.copyWithin(target, start, end)


<span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
<span class="built_in">console</span>.log(arr.copyWithin(<span class="number">3</span>))
 <span class="comment">// [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2</span>
<span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
<span class="built_in">console</span>.log(arr1.copyWithin(<span class="number">3</span>, <span class="number">1</span>)) 
<span class="comment">// [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3</span>
<span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
<span class="built_in">console</span>.log(arr2.copyWithin(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)) 
<span class="comment">// [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2</span>

<span class="number">9.</span>实例方法values()，keys(), entries() 

<span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];
<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr.values()) {
  <span class="built_in">console</span>.log(v)
}
<span class="comment">//'a' 'b' 'c'</span>

<span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];
<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr.keys()) {
  <span class="built_in">console</span>.log(v)
}
<span class="comment">// 0 1 2</span>

<span class="keyword">const</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];
<span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr.entries()) {
  <span class="built_in">console</span>.log(v)
}
<span class="comment">// [0, 'a'] [1, 'b'] [2, 'c']</span>
</code></pre><h4 id="2-_数组相关（从最新的开始写，那些方法改变了原数组，那些没有改变）">2. 数组相关（从最新的开始写，那些方法改变了原数组，那些没有改变）</h4><h5 id="改变原数组的方法">改变原数组的方法</h5><p>fill()—用新元素替换掉数组内的元素，可以指定替换下标范围。</p>
<pre><code>let oldArr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
let newArr1 = oldArr1.fill(<span class="number">6</span>); <span class="comment">//当为空数组时什么都不替换</span>
let newArr2 = oldArr2.fill(<span class="number">6</span>);
console.<span class="built_in">log</span>(oldArr1, oldArr2)
</code></pre><p>copyWithin()—选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。</p>
<pre><code>console.<span class="function"><span class="title">log</span><span class="params">(arr.copyWithin(<span class="number">3</span>)</span></span>, arr)
<span class="comment">//  [1, 2, 3, 1, 2]  [1, 2, 3, 1, 2]</span>
</code></pre><p>pop()—删除数组的最后一个元素并返回删除的元素。</p>
<pre><code><span class="label">let</span> <span class="keyword">popItem </span>= arr.<span class="keyword">pop();
</span><span class="label">console.log</span>(<span class="keyword">popItem, </span>arr)
// <span class="number">1</span>  , [<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]
</code></pre><p>push()—向数组的末尾添加一个或更多元素，并返回新的长度。</p>
<pre><code>let <span class="built_in">length</span> = arr.push(<span class="number">22</span>);
console.<span class="built_in">log</span>(<span class="built_in">length</span>, arr)
<span class="comment">// 7 ,  [9, 2, 4, 5, 6, 1, 22]</span>
</code></pre><p>shift()—删除并返回数组的第一个元素。</p>
<pre><code><span class="keyword">let</span> firstItem = arr.shift();
<span class="built_in">console</span>.log(firstItem, arr)
<span class="comment">// 9 , [2, 4, 5, 6, 1]</span>
</code></pre><p>unshift()—向数组的开头添加一个或更多元素，并返回新的长度。</p>
<pre><code>let newLength = arr.unshift(<span class="number">100</span>, <span class="number">20</span>);
console.<span class="built_in">log</span>(newLength, arr)
<span class="comment">// 8 [100, 20, 9, 2, 4, 5, 6, 1]</span>
</code></pre><p>reverse()—反转数组的元素顺序。</p>
<pre><code>arr.<span class="built_in">reverse</span>();
console.<span class="built_in">log</span>(arr)
<span class="comment">// [1, 6, 5, 4, 2, 9]</span>
</code></pre><p>sort()—对数组的元素进行排序。</p>
<pre><code><span class="keyword">let</span> arr1 = arr.sort();
<span class="built_in">console</span>.log(arr1, arr)
<span class="comment">// [1, 2, 4, 5, 6, 9] </span>
<span class="comment">// [1, 2, 4, 5, 6, 9]</span>
</code></pre><p>splice()—用于插入、删除或替换数组的元素。</p>
<pre><code><span class="comment">// splice(index,howmany,item1,.....,itemX)</span>
index    必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
howmany    必需。要删除的项目数量。如果设置为 <span class="number">0</span>，则不会删除项目。
item1, ..., itemX    可选。向数组添加的新项目。

let arr =[<span class="number">9</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>];
arr.splice(<span class="number">100</span>, <span class="number">0</span>,<span class="number">123</span>,<span class="number">1234</span>)
console.<span class="built_in">log</span>(arr)
<span class="comment">// [9, 2, 4, 5, 6, 1, 123, 1234]</span>
</code></pre><h5 id="不改变原数组的方法">不改变原数组的方法</h5><p>includes()— 判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。</p>
<pre><code>a.includes(<span class="number">2</span>);
console.<span class="built_in">log</span>(a)
<span class="comment">//  [1, 2, 3]</span>
</code></pre><p>keys()—返回键值对的key</p>
<pre><code><span class="label">let</span> <span class="keyword">brr </span>=  arr.keys()<span class="comment">;</span>
<span class="label">console.log</span>(arr, <span class="keyword">brr);
</span>//  [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]  Array <span class="keyword">Iterator </span>{}
</code></pre><p>values()— 返回迭代器：返回键值对的value</p>
<pre><code><span class="label">let</span> <span class="keyword">brr </span>=  arr.values()<span class="comment">;</span>
<span class="label">console.log</span>(arr, <span class="keyword">brr);
</span>// [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] Array <span class="keyword">Iterator </span>{}
</code></pre><p>entries()— 返回迭代器：返回键值对</p>
<pre><code><span class="label">let</span> <span class="keyword">brr </span>=  arr.entries()<span class="comment">;</span>
<span class="label">console.log</span>(arr, <span class="keyword">brr);
</span>// [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] Array <span class="keyword">Iterator </span>{}
</code></pre><p>find()—传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。</p>
<pre><code>let arr = [<span class="number">1</span>, <span class="string">"2"</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">"2"</span>]
console.<span class="built_in">log</span>(arr.find(n =&gt; typeof n === <span class="string">"number"</span>) , arr) 
<span class="comment">// 1 , [1, "2", 3, 3, "2"]</span>
</code></pre><p>findIndex()— 传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的索引，并且终止搜索</p>
<pre><code>console.<span class="literal">log</span>(arr.findIndex(<span class="keyword">n</span> =&gt; <span class="keyword">typeof</span> <span class="keyword">n</span> === <span class="string">"number"</span>) , arr)<span class="comment">// 0  , [1, "2", 3, 3, "2"]</span>
</code></pre><p>concat()—连接两个或更多的数组，并返回结果。</p>
<pre><code><span class="keyword">let</span> brr = [<span class="string">'foo'</span>, <span class="string">'boo'</span>];
<span class="keyword">let</span> crr = arr.concat(brr);
console.<span class="built_in">log</span>(crr)
// [<span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="string">"foo"</span>, <span class="string">"boo"</span>]
</code></pre><p>every()—检测数组元素的每个元素是否都符合条件。</p>
<pre><code>let falg = arr.every(<span class="function"><span class="params">(item, index)</span>=&gt;</span>{
    <span class="keyword">return</span> item &gt; <span class="number">4</span>
})
<span class="built_in">console</span>.log(falg);
<span class="regexp">//</span> <span class="literal">false</span>
</code></pre><p>some()—检测数组元素中是否有元素符合指定条件。</p>
<pre><code>let falg = arr.some(<span class="function"><span class="params">(item, index)</span>=&gt;</span>{
    <span class="keyword">return</span> item &gt; <span class="number">4</span>
})
<span class="built_in">console</span>.log(falg);
<span class="regexp">//</span> <span class="literal">true</span>
</code></pre><p>filter()—检测数组元素，并返回符合条件所有元素的数组。</p>
<pre><code>let brr = arr.filter(<span class="function"><span class="params">(item, index)</span>=&gt;</span>{
    <span class="keyword">return</span> item &gt; <span class="number">4</span>
})
<span class="built_in">console</span>.log(brr);
<span class="regexp">//</span>  [<span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>]
</code></pre><p>indexOf()—搜索数组中的元素，并返回它所在的位置。</p>
<pre><code><span class="keyword">let</span> <span class="built_in">index</span> = arr.indexOf(<span class="number">9</span>);
console.<span class="built_in">log</span>(<span class="built_in">index</span>);
// <span class="number">0</span>
</code></pre><p>join()—把数组的所有元素放入一个字符串。</p>
<pre><code>let <span class="built_in">str</span> = arr.<span class="built_in">join</span>(<span class="string">'-'</span>);
console.<span class="built_in">log</span>(<span class="built_in">str</span>, arr);
<span class="comment">// 9-2-4-5-6-1  , [9, 2, 4, 5, 6, 1]</span>
</code></pre><p>toString()—把数组转换为字符串，并返回结果。</p>
<pre><code><span class="built_in">let</span> <span class="built_in">str</span> = arr.toString();
console.<span class="built_in">log</span>(<span class="built_in">str</span>);
<span class="comment">// 9,2,4,5,6,1</span>
</code></pre><p>lastIndexOf()—返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p>
<pre><code><span class="keyword">let</span> <span class="built_in">index</span> = arr.lastIndexOf(<span class="number">9</span>);
console.<span class="built_in">log</span>(<span class="built_in">index</span>);
// <span class="number">0</span>
</code></pre><p>map()—通过指定函数处理数组的每个元素，并返回处理后的数组。</p>
<pre><code>let brr = arr.<span class="built_in">map</span>((item,index)=&gt;{
    <span class="keyword">return</span> {
        key: item,
        value: item+<span class="number">3</span>
    }
});
console.<span class="built_in">log</span>(brr);
<span class="comment">//  0: {key: 9, value: 12}</span>
    <span class="number">1</span>: {key: <span class="number">2</span>, value: <span class="number">5</span>}
    <span class="number">2</span>: {key: <span class="number">4</span>, value: <span class="number">7</span>}
    <span class="number">3</span>: {key: <span class="number">5</span>, value: <span class="number">8</span>}
    <span class="number">4</span>: {key: <span class="number">6</span>, value: <span class="number">9</span>}
    <span class="number">5</span>: {key: <span class="number">1</span>, value: <span class="number">4</span>}
</code></pre><p>slice(start,end)—选取数组的的一部分，并返回一个新数组。</p>
<pre><code>let brr = arr.slice(<span class="number">2</span>,<span class="number">4</span>);
console.<span class="built_in">log</span>(brr);
<span class="comment">// [4, 5]</span>
</code></pre><p>valueOf()—返回数组对象的原始值。</p>
<pre><code>let <span class="keyword">brr</span> = arr.valueOf();
console.<span class="literal">log</span>(<span class="keyword">brr</span>);
<span class="comment">// [9, 2, 4, 5, 6, 1]</span>
</code></pre><h4 id="3-_对象相关（新增了那些方法，怎么使用（平常项目中使用过那些））">3. 对象相关（新增了那些方法，怎么使用（平常项目中使用过那些））</h4><pre><code><span class="comment">// 对象新增的方法</span>

<span class="comment">// 它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致</span>
<span class="built_in">Object</span>.<span class="keyword">is</span>()

<span class="comment">// Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</span>
<span class="built_in">Object</span>.assign()

<span class="comment">// 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</span>
<span class="built_in">Object</span>.keys()

<span class="comment">// Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</span>
<span class="built_in">Object</span>.values()

<span class="comment">//  Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组</span>

<span class="keyword">const</span> obj = { foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> };
<span class="built_in">Object</span>.entries(obj)
<span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span>


<span class="comment">//  Object.fromEntries() 该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map结构转为对象。Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。用于将一个键值对数组转为对象。该方法的一个用处是配合URLSearchParams对象，将查询字符串转为对象</span>

<span class="built_in">Object</span>.fromEntries([
  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],
  [<span class="string">'baz'</span>, <span class="number">42</span>]
])
<span class="comment">// { foo: "bar", baz: 42 }</span>

<span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(<span class="string">'foo=bar&amp;baz=qux'</span>))
<span class="comment">// { foo: "bar", baz: "qux" }</span>
</code></pre><h4 id="4-_字符串相关（新增了那些方法，怎么使用（平常项目中使用过那些））">4. 字符串相关（新增了那些方法，怎么使用（平常项目中使用过那些））</h4><p>indexOf()方法和lastIndexOf()方法能接收2个参数，第一个参数为要寻找的字符串，第二个为开始位置，如果不写开始位置，会在全局找，无论从哪个位置开始找，返回的都是第一次出现的位置的下标。</p>
<pre><code>console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">'rf'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.lastIndexOf(<span class="string">'rf'</span>));
<span class="comment">// 10</span>
<span class="comment">// 10</span>
console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">'rf'</span>, <span class="number">2</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.lastIndexOf(<span class="string">'rf'</span>, <span class="number">5</span>));
<span class="comment">// 10</span>
<span class="comment">// 10</span>
</code></pre><p>includes()方法—同样能接收2个参数，填写一个参数在全局找，填写第二个参数，则从填写的位置往后找。如果找到返回true，没找到返回false。</p>
<pre><code>console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">'rf'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">'rf'</span>, <span class="number">20</span>));
<span class="comment">// true  false</span>
</code></pre><p>startsWith()方法—查询是否以什么什么开头，同样能接收2个参数，1个参数的话在全局找，2个参数的话则从填写的位置往后找，找到返回true，没找到返回false。</p>
<pre><code>console.<span class="keyword">log</span>(str.<span class="keyword">startsWith</span>(<span class="string">'adf'</span>));
console.<span class="keyword">log</span>(str.<span class="keyword">startsWith</span>(<span class="string">'rf'</span>, <span class="number">10</span>));
console.<span class="keyword">log</span>(str.<span class="keyword">startsWith</span>(<span class="string">'rf'</span>));
<span class="comment">// true  true false</span>
</code></pre><p>endsWith()方法—用法与第3个一样，如果填写第二个参数的话，则是从填写的位置往前找</p>
<pre><code>console.<span class="keyword">log</span>(str.<span class="keyword">endsWith</span>(<span class="string">'zle'</span>));
console.<span class="keyword">log</span>(str.<span class="keyword">endsWith</span>(<span class="string">'zl'</span>, <span class="number">17</span>));
console.<span class="keyword">log</span>(str.<span class="keyword">endsWith</span>(<span class="string">'rf'</span>));
<span class="comment">// true true false</span>
</code></pre><p>repeat() —收一个Number类型的数据，返回一个新的字符串，表示将原字符串重复 n 次。</p>
<p>padStart()方法—用于头部补全，接收2个参数，第一个参数是补全后的字符串的最大长度，第二个是要补的字符串，返回的是补全后的字符串。如果原字符串长度大于第一个参数，则会返回原字符串。如果不写第二个参数，则会用空格替补。</p>
<pre><code>console.<span class="built_in">log</span>(<span class="built_in">str</span>.padStart(<span class="number">4</span>, <span class="string">'djw'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padStart(<span class="number">10</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padStart(<span class="number">10</span>, <span class="string">'djw'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padStart(<span class="number">10</span>, <span class="string">'djwdjw'</span>));
<span class="comment">// hello</span>
<span class="comment">//     hello</span>
<span class="comment">// djwdjhello</span>
<span class="comment">// djwdjhello</span>
</code></pre><p>padEnd()方法—用于尾部填充，用法与上面一样。</p>
<pre><code>console.<span class="built_in">log</span>(<span class="built_in">str</span>.padEnd(<span class="number">4</span>, <span class="string">'djw'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padEnd(<span class="number">10</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padEnd(<span class="number">10</span>, <span class="string">'djw'</span>));
console.<span class="built_in">log</span>(<span class="built_in">str</span>.padEnd(<span class="number">10</span>, <span class="string">'djwdjw'</span>));
<span class="comment">// hello</span>
<span class="comment">// hello     </span>
<span class="comment">// hellodjwdj</span>
<span class="comment">// hellodjwdj</span>
</code></pre><p>toLowerCase()—把字符串转为小写，返回新的字符串。</p>
<pre><code>var str1=<span class="built_in">str</span>.toLowerCase();
console.<span class="built_in">log</span>(<span class="built_in">str</span>); <span class="comment">//Hello World</span>
console.<span class="built_in">log</span>(str1); <span class="comment">//hello world</span>
</code></pre><p>toUpperCase()—串转为大写，返回新的字符串。</p>
<pre><code>var str1=<span class="built_in">str</span>.toUpperCase();
console.<span class="built_in">log</span>(<span class="built_in">str</span>); <span class="comment">//hello world</span>
console.<span class="built_in">log</span>(str1); <span class="comment">//HELLO WORLD</span>
</code></pre><p>charAt()—返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。</p>
<pre><code>var str1=str.charAt(<span class="number">6</span>);
console.<span class="built_in">log</span>(str1); <span class="comment">// w</span>
</code></pre><p>charCodeAt()—返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。</p>
<pre><code><span class="variable"><span class="keyword">var</span> str1</span>=str.charCodeAt(<span class="number">1</span>);
<span class="variable"><span class="keyword">var</span> str2</span>=str.charCodeAt(-<span class="number">2</span>); <span class="comment">//NaN</span>
console.log(str1); <span class="comment">//101</span>
</code></pre><p>slice(): 返回字符串中提取的子字符串。</p>
<pre><code>var str1=str.slice(<span class="number">2</span>); <span class="comment">//如果只有一个参数，则提取开始下标到结尾处的所有字符串</span>
var str2=str.slice(<span class="number">2</span>,<span class="number">7</span>); <span class="comment">//两个参数，提取下标为2，到下标为7但不包含下标为7的字符串</span>
var str3=str.slice(-<span class="number">7</span>,-<span class="number">2</span>); <span class="comment">//如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串</span>

console.<span class="built_in">log</span>(str1); <span class="comment">//llo World</span>
console.<span class="built_in">log</span>(str2); <span class="comment">//llo W</span>
console.<span class="built_in">log</span>(str3); <span class="comment">//o Wor</span>
</code></pre><p>substring()—提取字符串中介于两个指定下标之间的字符。</p>
<pre><code>var str1=str.substring(<span class="number">2</span>)
var str2=str.substring(<span class="number">2</span>,<span class="number">2</span>);
var str3=str.substring(<span class="number">2</span>,<span class="number">7</span>);
console.<span class="built_in">log</span>(str1); <span class="comment">//llo World</span>
console.<span class="built_in">log</span>(str2); <span class="comment">//如果两个参数相等，返回长度为0的空串</span>
console.<span class="built_in">log</span>(str3); <span class="comment">//llo W</span>
</code></pre><p>substr()—返回从指定下标开始指定长度的的子字符串</p>
<pre><code><span class="keyword">var</span> str1=str.<span class="literal">substr</span>(1)
<span class="keyword">var</span> str2=str.<span class="literal">substr</span>(1,3);
<span class="keyword">var</span> str3=str.<span class="literal">substr</span>(-3,2);
console.<span class="literal">log</span>(str1); <span class="comment">//ello World </span>
console.<span class="literal">log</span>(str2); <span class="comment">//ell</span>
console.<span class="literal">log</span>(str3); <span class="comment">//rl</span>
</code></pre><p>split()— 把字符串分割成字符串数组。</p>
<pre><code>var string1=<span class="string">"1:2:3:4:5"</span>;
var str1=str.<span class="keyword">split</span>(<span class="string">""</span>);<span class="regexp">//</span>如果把空字符串 (<span class="string">""</span>)用作分割符，那么字符串的每个字符之间都会被分割
var str2=str.<span class="keyword">split</span>(<span class="string">" "</span>); <span class="regexp">//</span>以空格为分隔符
var str3=str.<span class="keyword">split</span>(<span class="string">""</span>,<span class="number">4</span>); <span class="regexp">//</span><span class="number">4</span>指定返回数组的最大长度
var str4=string1.<span class="keyword">split</span>(<span class="string">":"</span>);
console.<span class="keyword">log</span>(str1); <span class="regexp">//</span> [<span class="string">"A"</span>, <span class="string">"A"</span>, <span class="string">" "</span>, <span class="string">"B"</span>, <span class="string">"B"</span>, <span class="string">" "</span>, <span class="string">"C"</span>, <span class="string">"C"</span>, <span class="string">" "</span>, <span class="string">"D"</span>, <span class="string">"D"</span>]
console.<span class="keyword">log</span>(str2); <span class="regexp">//</span>[<span class="string">"AA"</span> <span class="string">"BB"</span> <span class="string">"CC"</span> <span class="string">"DD"</span>]
console.<span class="keyword">log</span>(str3); <span class="regexp">//</span>[<span class="string">"A"</span>, <span class="string">"A"</span>, <span class="string">" "</span>, <span class="string">"B"</span>]
console.<span class="keyword">log</span>(str4); <span class="regexp">//</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>]
</code></pre><p>replace()—在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<pre><code><span class="keyword">var</span> <span class="keyword">reg</span>=/o/ig; <span class="comment">//o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。</span>
<span class="keyword">var</span> str1=str.<span class="keyword">replace</span>(<span class="keyword">reg</span>,<span class="string">"**"</span>)
console.<span class="literal">log</span>(str1); <span class="comment">//hell** W**RLD</span>
</code></pre><p>match(): 返回所有查找的关键字内容的数组。</p>
<pre><code><span class="keyword">var</span> <span class="keyword">reg</span>=/to/ig;
<span class="keyword">var</span> str1=str.<span class="literal">match</span>(<span class="keyword">reg</span>);
console.<span class="literal">log</span>(str1); <span class="comment">//["To", "to"]</span>
console.<span class="literal">log</span>(str.<span class="literal">match</span>(<span class="string">"Hello"</span>)); <span class="comment">//null</span>
</code></pre><h4 id="5-_数组和对象相互转换，在那些情况下可以相互转换">5. 数组和对象相互转换，在那些情况下可以相互转换</h4><p>Object.keys()</p>
<pre><code><span class="keyword">let</span> obj = {
    name: <span class="string">'haha'</span>, 
    age: <span class="number">20</span>,
    showName:  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{}
}
<span class="built_in">Object</span>.keys(obj)   <span class="comment">//['name','age','showName']</span>

<span class="comment">// 组合用法</span>
<span class="keyword">let</span> obj = {
    name: <span class="string">'haha'</span>, 
    age: <span class="number">20</span>, 
}

<span class="built_in">Object</span>.keys(obj).map((val, index)=&gt;{
　 <span class="keyword">return</span>　obj[val] <span class="comment">// 可以针对obj的不同属性做不同处理</span>
}) 
</code></pre><p>Object.values();</p>
<pre><code><span class="keyword">let</span> obj = {
    name: <span class="string">'haha'</span>, 
    age: <span class="number">20</span>,
    showName:  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{}
}
<span class="built_in">Object</span>.values(obj)   <span class="comment">//['haha','20', f]</span>
</code></pre><p>Object.entries()</p>
<pre><code><span class="atom">console</span>.<span class="atom">log</span>(<span class="name">Object</span>.<span class="atom">entries</span>(<span class="atom">obj</span>)); // [ [<span class="string">'foo'</span>, <span class="string">'bar'</span>], [<span class="string">'baz'</span>, <span class="number">42</span>] ]

<span class="atom">const</span> <span class="atom">anObj</span> = { <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> };
<span class="atom">console</span>.<span class="atom">log</span>(<span class="name">Object</span>.<span class="atom">entries</span>(<span class="atom">anObj</span>)); // [ [<span class="string">'2'</span>, <span class="string">'b'</span>], [<span class="string">'7'</span>, <span class="string">'c'</span>], [<span class="string">'100'</span>, <span class="string">'a'</span>] ]


<span class="atom">console</span>.<span class="atom">log</span>(<span class="name">Object</span>.<span class="atom">entries</span>(<span class="string">'foo'</span>)); // [ [<span class="string">'0'</span>, <span class="string">'f'</span>], [<span class="string">'1'</span>, <span class="string">'o'</span>], [<span class="string">'2'</span>, <span class="string">'o'</span>] ]

// 更优雅的遍历对象键值：
<span class="atom">const</span> <span class="atom">obj</span> = { <span class="atom">a</span>: <span class="number">5</span>, <span class="atom">b</span>: <span class="number">7</span>, <span class="atom">c</span>: <span class="number">9</span> };
<span class="atom">for</span> (<span class="atom">const</span> [<span class="atom">key</span>, <span class="atom">value</span>] <span class="atom">of</span> <span class="name">Object</span>.<span class="atom">entries</span>(<span class="atom">obj</span>)) {
  <span class="atom">console</span>.<span class="atom">log</span>(<span class="string">`${key} ${value}`</span>); 
  // <span class="string">"a 5"</span>, <span class="string">"b 7"</span>, <span class="string">"c 9"</span>
}

// 或者
<span class="name">Object</span>.<span class="atom">entries</span>(<span class="atom">obj</span>).<span class="atom">forEach</span>(([<span class="atom">key</span>, <span class="atom">value</span>]) =&gt; {
<span class="atom">console</span>.<span class="atom">log</span>(<span class="string">`${key} ${value}`</span>); // <span class="string">"a 5"</span>, <span class="string">"b 7"</span>, <span class="string">"c 9"</span>
});
</code></pre><p>Object.fromEntries()</p>
<pre><code><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr);
<span class="built_in">console</span>.log(obj); <span class="comment">// { 0: "a", 1: "b", 2: "c" }</span>
</code></pre><h4 id="6-_var，let，const_的区别，和实现原理">6. var，let，const 的区别，和实现原理</h4><h4 id="7-_实现深拷贝">7. 实现深拷贝</h4><h4 id="8-_获取页面中的全部标签，并计算个数">8. 获取页面中的全部标签，并计算个数</h4><h4 id="9-_节流和防抖，原理以及实现">9. 节流和防抖，原理以及实现</h4><h4 id="10-_call，apply，bing的原理与实现">10. call，apply，bing的原理与实现</h4><h4 id="11-_promise的相关概念及实现">11. promise的相关概念及实现</h4><h4 id="12-_箭头函数中的this，箭头函数与function的区别">12. 箭头函数中的this，箭头函数与function的区别</h4><h4 id="13-_介绍一下set，map，weakSet和weakMap的区别">13. 介绍一下set，map，weakSet和weakMap的区别</h4><h4 id="14-_settimeout_,_promise,_async/await的区别">14. settimeout , promise, async/await的区别</h4><h4 id="15-_async/await如何通过同步的方式实现异步">15. async/await如何通过同步的方式实现异步</h4><h4 id="16-_js异步解决方案的发展历程及其优缺点（amd，cmd，commonjs，es6的module）">16. js异步解决方案的发展历程及其优缺点（amd，cmd，commonjs，es6的module）</h4><h4 id="17-_for循环和foreach哪个执行效率更高，为什么">17. for循环和foreach哪个执行效率更高，为什么</h4><h4 id="18-_js判断数字，字母，中文，符号并截取16位">18. js判断数字，字母，中文，符号并截取16位</h4><h4 id="19-_手写实现js的多种继承方式">19. 手写实现js的多种继承方式</h4><h4 id="20-_使用settimeout实现setinterval，有什么优点">20. 使用settimeout实现setinterval，有什么优点</h4><h4 id="21-_js闭包的概念，闭包的使用场景，以及闭包的优缺点">21. js闭包的概念，闭包的使用场景，以及闭包的优缺点</h4><h4 id="22-_js中this的指向">22. js中this的指向</h4><h4 id="23-_js的原型链">23. js的原型链</h4><h4 id="24-_js的内存管理机制">24. js的内存管理机制</h4><h4 id="25-_js的作用域与作用域链">25. js的作用域与作用域链</h4><h4 id="26-_什么是xss和csrf，并如何防止">26. 什么是xss和csrf，并如何防止</h4><h4 id="27-_es6的class和构造函数的区别">27. es6的class和构造函数的区别</h4><h4 id="28-_js中的变量提升（和函数提升）">28. js中的变量提升（和函数提升）</h4><h4 id="29-_js的事件捕获和事件冒泡">29. js的事件捕获和事件冒泡</h4><h4 id="30-_onclick和addeventListener（第三个参数）绑定同一个元素，那个先执行，那个后执行">30. onclick和addeventListener（第三个参数）绑定同一个元素，那个先执行，那个后执行</h4><p>根据初始化函数的注册顺序，从上往下执行。<br>如果是以下这样</p>
<pre><code>&lt;button class=<span class="string">"a"</span>&gt;fdfasf&lt;/button&gt;

document.querySelector(<span class="string">'.a'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(params)</span></span> {
    console.log(<span class="string">'addeventListener 冒泡'</span>);
}, <span class="keyword">false</span>);
document.querySelector(<span class="string">'.a'</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {
        console.log(<span class="string">'onclick1'</span>);
    }
document.querySelector(<span class="string">'.a'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(params)</span></span> {
    console.log(<span class="string">'addeventListener 捕获'</span>);
}, <span class="keyword">true</span>);
document.querySelector(<span class="string">'.a'</span>).onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> {
    console.log(<span class="string">'onclick2'</span>);
}
// 打印 addeventListener 冒泡 onclick2  addeventListener 捕获
</code></pre><h4 id="31-_两个onclick事件，是执行第一个还是执行第二个">31. 两个onclick事件，是执行第一个还是执行第二个</h4><p>在js中写多个onclick事件绑定相同元素，只会触发最后一个绑定的事件。</p>
<h4 id="32-_怎么让函数只执行一次，addeventListener的第三个参数都有哪些">32. 怎么让函数只执行一次，addeventListener的第三个参数都有哪些</h4><ol>
<li>设置标志位</li>
<li></li>
</ol>
<h4 id="33-_new一个对象的过程">33. new一个对象的过程</h4><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了构造函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this</p>
<h4 id="34-_如何判断一个js的变量是什么数据类型，有哪几种方式">34. 如何判断一个js的变量是什么数据类型，有哪几种方式</h4><p>type, instanceof, Object.prototype.toString.call();</p>
<p>type 只能判断 number，string，boolean，undefined，object和function，在es6中又新增了symbol，无法判断Array，object，和null（因为判断出来都是object）</p>
<p>在判断是否是数组的时候，可以用es6中新增的方法Array.isArray()，也可以用instanceof</p>
<p>instanceof的原理：<br>构造函数的prototype属性是否出现在对象的原型链中的任何位置</p>
<p>如果想精确判断是那种数据类型，建议使用<code>Object.prototype.toString.call()</code></p>
<h4 id="35-_js中如何防止一个对象被修改（删除，添加）">35. js中如何防止一个对象被修改（删除，添加）</h4><ol>
<li><p>不可扩展对象（不能再给对象添加属性和方法）</p>
<p> Object.preventExtensions(person);//设置为防拓展对象<br> Object.isExtensible(person);//用来确定对象是否可扩展。</p>
</li>
<li><p>密封对象（不能删除属性和方法）</p>
<p> Object.seal(person);//将对象密封<br> Object.isSealed(person）; // 检测对象是否被密封</p>
</li>
<li><p>冻结对象（不能修改属性和方法）</p>
<p> Object.freeze(man); // 冻结对象<br> Object.isFrozen(man); // 检测对象是否被冻结</p>
</li>
<li><p>使用Object.defineProperty的writable</p>
<p> var person = function() {</p>
<pre><code>this<span class="class">.name</span> = <span class="string">'a'</span>
</code></pre><p> }<br> var p = new person();<br> Object.defineProperty(p, ‘name’, {</p>
<pre><code><span class="string">writable:</span> <span class="literal">false</span>
</code></pre><p> })<br> p.name = ‘b’;<br> console.log(p.name) // a</p>
</li>
</ol>
<h4 id="36-_浏览器中的event-loop">36. 浏览器中的event-loop</h4><p>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p>
<p>setTimeout的第二个参数不得小于 4 毫秒，不足会自动增加</p>
<p>同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p>
<p>微任务包括 <code>process.nextTick ，promise ，Object.observe ，MutationObserver</code><br>宏任务包括 <code>script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering</code></p>
<p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p>
<p>所以正确的一次 Event loop 顺序是这样的</p>
<p>执行同步代码，这属于宏任务<br>执行栈为空，查询是否有微任务需要执行<br>执行所有微任务<br>必要的话渲染 UI<br>然后开始下一轮 Event loop，执行宏任务中的异步代码</p>
<h4 id="37-_cookie，sessionStorage，localStorage和indexDB的使用场景和优缺点">37. cookie，sessionStorage，localStorage和indexDB的使用场景和优缺点</h4><p>cookie：key/value 一般大小4k，每次访问都要传送cookie给服务器，可以设置过期时间，和域名绑定<br>localstorage：key/value 一直存储于本地硬盘（浏览器中可以删除），一般数据最大5MB（各个浏览器不一样），和域名绑定<br>sessionStorage：key/value 关闭页面或浏览器后被清除，最大5MB，和域名绑定<br>indexDB：key/object 可以存储对象，浏览器中的数据库，异步，支持事务，和域名绑定，存储空间大</p>
<p>总结：<br>LocalStorage、SessionStorage和Cookie都是通过域名进行隔离的。</p>
<p>全局存储：LocalStorage、Cookie<br>自动参与HTTP通信：Cookie<br>实现不同tab保存不同的数据：SessionStorage<br>存储大量数据：IndexDB</p>
<p>应用：登录相关可以考虑使用Cookie。</p>
<h4 id="38-_什么是函数式编程，什么是纯函数">38. 什么是函数式编程，什么是纯函数</h4><p><a href="https://www.jianshu.com/p/01cbebd9655d" target="_blank" rel="external">https://www.jianshu.com/p/01cbebd9655d</a></p>
<p>函数式编程：<br>通过最小化变化使得代码更易理解</p>
<p>纯函数定义：<br>对于相同的输入，永远得到相同的输出，它不依赖外部环境，也不会改变外部环境</p>
<h4 id="39-_如何优化递归（尾递归）">39. 如何优化递归（尾递归）</h4><p><a href="https://juejin.im/post/5acdd7486fb9a028ca53547c" target="_blank" rel="external">尾调用和尾递归</a><br>递归<br>当一个函数在内部调用自身，就可以称为一个递归</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span> </span>{
    foo();
}
</code></pre><p>这里没有结束条件，是死递归，所以会报栈溢出错误的，写代码时千万注意给递归添加结束条件。</p>
<p>什么是尾递归<br>当一个函数尾调用自身，就叫做尾递归。</p>
<p>例子：<br>    function foo () {<br>        return foo();<br>    }</p>
<p>好处：</p>
<h4 id="40-_函数柯里化">40. 函数柯里化</h4><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>好处：</p>
<ol>
<li>参数复用</li>
<li>提前确认</li>
<li>延迟运行</li>
</ol>
<p>curry的一些性能问题你只要知道下面四点就差不多了：</p>
<p>(1) 存取arguments对象通常要比存取命名参数要慢一点<br>(2) 一些老版本的浏览器在arguments.length的实现上是相当慢的<br>(3) 使用fn.apply( … ) 和 fn.call( … )通常比直接调用fn( … ) 稍微慢点<br>(4) 创建大量嵌套作用域和闭包函数会带来花销，无论是在内存还是速度上</p>
<p>例子： </p>
<pre><code><span class="comment">// 实现一个add方法，使计算结果能够满足如下预期：</span>
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) = <span class="number">6</span>;
add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>) = <span class="number">10</span>;
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>) = <span class="number">15</span>;

<span class="function">function <span class="title">add</span><span class="params">()</span> </span>{
    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span>
    var _args = Array.prototype.slice.call(arguments);

    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span>
    var _adder = function() {
        _args.push(...arguments);
        <span class="keyword">return</span> _adder;
    };

    <span class="comment">// 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span>
    _adder.toString = function () {
        <span class="keyword">return</span> _args.reduce(function (a, b) {
            <span class="keyword">return</span> a + b;
        });
    }
    <span class="keyword">return</span> _adder;
}

add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)                <span class="comment">// 6</span>
add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>)             <span class="comment">// 10</span>
add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)          <span class="comment">// 15</span>
add(<span class="number">2</span>, <span class="number">6</span>)(<span class="number">1</span>)                <span class="comment">// 9</span>
</code></pre><h4 id="41-_函数的arguments，arguments中都有什么属性">41. 函数的arguments，arguments中都有什么属性</h4><p>作用：<br>用于储存调用函数时的所有实参（arguments数组的个数，取决于实参列表，与形参无关）<br>arguments.callee()是arguments的重要属性。表示arguments所在函数的引用地址</p>
<pre><code><span class="function">function <span class="title">name</span><span class="params">()</span> </span>{
    console.<span class="built_in">log</span>(arguments);
}
name(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)
<span class="comment">// 打印出</span>
arguments {
    <span class="number">0</span>: <span class="number">1</span>
    <span class="number">1</span>: <span class="number">2</span>
    <span class="number">2</span>: <span class="number">3</span>
    callee: ƒ name()
    length: <span class="number">3</span>
    Symbol(Symbol.iterator): ƒ values()
    __proto__: Object
}
</code></pre><h4 id="42-_js的跨域通信">42. js的跨域通信</h4><p>当域名不是同一协议，同一域名或者同一端口号，则会根据浏览器的默认安全策略会产生跨域的问题。</p>
<h4 id="43-_js如何实现懒加载">43. js如何实现懒加载</h4><p>原理:<br>每个图片的src会有一个get请求，我们把不能看到的图片src设置为相同的图片，这些图片发一次请求即可，设置属性data-src为真正的图片路径。当图片滚动到可视区，我们就用js把data-src 赋值给 src，简单的懒加载就可以实现了。</p>
<p>如何判断是否在可视区</p>
<h5 id="就是_图片的_offsetTop_&lt;_scrollTop_+_clientHeigth_即可">就是 图片的 offsetTop &lt;  scrollTop + clientHeigth 即可</h5><pre><code>offsetTop <span class="comment">// 元素距离文档顶部的距离</span>
scrollTop <span class="comment">// 滚动的距离</span>
clientHeigth <span class="comment">// 窗口的高度</span>
</code></pre><p>代码：</p>
<pre><code><span class="keyword">let</span> imgArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);
<span class="keyword">let</span> len = imgArr.length;
<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight;
    <span class="built_in">console</span>.log(<span class="string">"seeHeight ="</span>+seeHeight);
    <span class="keyword">let</span> scrollTop =  <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;
    <span class="built_in">console</span>.log(<span class="string">"scrollTop ="</span>+scrollTop);
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++){
        <span class="built_in">console</span>.log(imgArr[i].offsetTop);
        <span class="keyword">if</span>(imgArr[i].offsetTop &lt; seeHeight + scrollTop){
                <span class="keyword">if</span>(imgArr[i].getAttribute(<span class="string">'src'</span>)==<span class="string">'timg.jpg'</span>){
                    imgArr[i].src = imgArr[i].getAttribute(<span class="string">'data-src'</span>);
                }
        }
    }
}
</code></pre><p>优化：<br>1.在初始条件下，应该有图片显示，只要在加载完毕之后滚动之前执行图片的加载即可</p>
<p>2.函数节流，但我们在高频度的滚动时，每隔一段事件开始图片的渲染。实现原理是 加入一个开关变量, 控制每隔固定的一段时间,函数才可能被触发</p>
<p>优化后代码：</p>
<pre><code><span class="keyword">let</span> imgArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img'</span>);
<span class="keyword">let</span> len = imgArr.length;
<span class="keyword">let</span> n = <span class="number">0</span>; <span class="comment">//记录加载图片的位置，避免从第一张开始加载</span>
<span class="keyword">let</span> canrun = <span class="literal">true</span>;
<span class="keyword">let</span> seeHeight = <span class="built_in">document</span>.documentElement.clientHeight;
<span class="built_in">console</span>.log(<span class="string">"seeHeight ="</span>+seeHeight);

lazyLoad();
<span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
    <span class="keyword">if</span>(!canrun){
        <span class="keyword">return</span> ;
    }
    canrun = <span class="literal">false</span>;
    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'*****'</span>);
        lazyLoad();
        canrun= <span class="literal">true</span>;
    },<span class="number">1000</span>);

}

<span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>) </span>{
    <span class="keyword">let</span> scrollTop =  <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;
    <span class="built_in">console</span>.log(<span class="string">"scrollTop ="</span>+scrollTop);
    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;len; i++){
        <span class="built_in">console</span>.log(imgArr[i].offsetTop);
        <span class="keyword">if</span>(imgArr[i].offsetTop &lt; seeHeight + scrollTop){
            <span class="keyword">if</span>(imgArr[i].getAttribute(<span class="string">'src'</span>)==<span class="string">'timg.jpg'</span>){
                imgArr[i].src = imgArr[i].getAttribute(<span class="string">'data-src'</span>);
            }
            n = i+<span class="number">1</span>;
            <span class="built_in">console</span>.log(<span class="string">"n="</span>+n);
        }
    }
}
</code></pre><h4 id="44-_js对象转化为字符串的步骤，数组与对象的相互转化（存疑）">44. js对象转化为字符串的步骤，数组与对象的相互转化（存疑）</h4><p>js对象转化为字符串的步骤：<br>首先调用toString方法，只有当toString不返回一个原始值的时候，才会调用valueOf()。toString方法但是基本上所有对象都返回字符串。所以对象到字符串形式的转换基本都是使用toString方法。<br>俩个方法都不返回原始值时，会抛出错误。</p>
<p>数组转对象：</p>
<h4 id="45-_什么是防御式编程">45. 什么是防御式编程</h4><p>主要思想<br>子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。</p>
<h4 id="46-_有没有写过npm包，怎么设计的，用什么模块化方式（commonjs，es6的module，ump等）">46. 有没有写过npm包，怎么设计的，用什么模块化方式（commonjs，es6的module，ump等）</h4><h4 id="47-_js中有几种方法定义函数">47. js中有几种方法定义函数</h4><p>1、使用function关键字定义函数 – 具有优先级，优先将function关键字定义的函数优先执行</p>
<p>　　function  functionName(arg0, arg1 ,…, argN){<br>　　　　　　statements<br>　　}<br>　　函数的调用：functionName()</p>
<p>2、使用函数表达式的形式定义函数（即将匿名函数复制给变量）</p>
<p> 　　var  variable = function(arg0, arg1 ,…, argN){<br>　　　　statements<br>　　 }<br>　　console.log(typeof  variable);     //function<br>　　函数调用：variable();</p>
<p>3、使用new Function构造函数定义函数</p>
<p>　　var  variable = new Function(‘name’,’alert(“hello,”+name)’);      //最末尾的是函数体，其前面的都是参数<br>　　console.log(typeof  variable);     //function<br>　　函数调用：variable(‘world’);</p>
<p>注意：</p>
<p>（1）使用fucntion关键字定义的函数，函数一旦声明，允许任意调用（在函数定义前、函数定义后、函数内部，可以在任意位置调用）<br>（2）使用函数表达式、new Function构造函数定义的函数，不能在函数定义前使用</p>
<h4 id="48-_focus/blur与focusin/focusout的区别与联系">48. focus/blur与focusin/focusout的区别与联系</h4><p>focus/blur不冒泡，focusin/focusout冒泡<br>focus/blur兼容性好，focusin/focusout在除FireFox外的浏览器下都保持良好兼容性，如需使用事件托管，可考虑在FireFox下使用事件捕获elem.addEventListener(‘focus’, handler, true)</p>
<h4 id="49-_用js实现千位分隔符">49. 用js实现千位分隔符</h4><pre><code>function <span class="keyword">format</span> (num) {
    <span class="keyword">var</span> <span class="keyword">reg</span>=/\<span class="keyword">d</span>{1,3}(?=(\<span class="keyword">d</span>{3})+$)/<span class="keyword">g</span>; 
    <span class="keyword">return</span> (num + '').<span class="keyword">replace</span>(<span class="keyword">reg</span>, '$&amp;,');
}
</code></pre><p>正则表达式 \d{1,3}(?=(\d{3})+$)  表示前面有1~3个数字，后面的至少由一组3个数字结尾。</p>
<p>?=表示正向引用，可以作为匹配的条件，但匹配到的内容不获取，并且作为下一次查询的开始。</p>
<p> $&amp; 表示与正则表达式相匹配的内容，具体的使用可以查看字符串replace()方法的</p>
<h4 id="50-_ie和dom事件流区别">50. ie和dom事件流区别</h4><ol>
<li>事件流的区别 </li>
</ol>
<p>IE采用冒泡型事件 Netscape使用捕获型事件 DOM使用先捕获后冒泡型事件<br>示例： </p>
<p>复制代码代码如下:</p>
<pre><code><span class="tag">&lt;<span class="title">body</span>&gt;</span> 
<span class="tag">&lt;<span class="title">div</span>&gt;</span> 
<span class="tag">&lt;<span class="title">button</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="title">button</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">div</span>&gt;</span> 
<span class="tag">&lt;/<span class="title">body</span>&gt;</span> 
</code></pre><p>冒泡型事件模型： button-&gt;div-&gt;body (IE事件流) </p>
<p>捕获型事件模型： body-&gt;div-&gt;button (Netscape事件流) </p>
<p>DOM事件模型： body-&gt;div-&gt;button-&gt;button-&gt;div-&gt;body (先捕获后冒泡) </p>
<ol>
<li>事件侦听函数的区别 </li>
</ol>
<p>IE使用: </p>
<pre><code><span class="attr_selector">[Object]</span><span class="class">.attachEvent</span>(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//绑定函数 </span>
<span class="attr_selector">[Object]</span><span class="class">.detachEvent</span>(<span class="string">"name_of_event_handler"</span>, fnHandler); <span class="comment">//移除绑定 </span>
</code></pre><p>DOM使用： </p>
<pre><code><span class="attr_selector">[Object]</span><span class="class">.addEventListener</span>(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//绑定函数 </span>
<span class="attr_selector">[Object]</span><span class="class">.removeEventListener</span>(<span class="string">"name_of_event"</span>, fnHandler, bCapture); <span class="comment">//移除绑定 </span>
</code></pre><p>bCapture参数用于设置事件绑定的阶段，true为捕获阶段，false为冒泡阶段。</p>
<h4 id="51-_js怎么实现精确倒计时">51. js怎么实现精确倒计时</h4><p><a href="http://www.xuanfengge.com/js-realizes-precise-countdown.html" target="_blank" rel="external">http://www.xuanfengge.com/js-realizes-precise-countdown.html</a></p>
<h4 id="52-_js的数组降纬">52. js的数组降纬</h4><ol>
<li><p>使用flat</p>
<p> [1, [2, [3]]].flat(Infinity) // 参数可以是数字，可以拉平传入数字的n+1层，不写默认两层，Infinity默认全部拉平</p>
</li>
<li><p>flatMap() 只能拉平二维数组</p>
</li>
<li><p>使用递归</p>
<p> let newArr = [];<br> function flatArr (arr) {</p>
<pre><code>for<span class="list">(<span class="keyword">let</span> i=0<span class="comment">; i&lt;arr.length; i++) {</span>
    if<span class="list">(<span class="keyword">arr</span>[i] instanceof Array)</span> {
       flatArr<span class="list">(<span class="keyword">arr</span>[i])</span><span class="comment">;</span>
    }else {
        newArr.push<span class="list">(<span class="keyword">arr</span>[i])</span><span class="comment">;</span>
    }
}</span>
</code></pre><p> }</p>
</li>
<li><p>使用reduce</p>
<p> const flattenDeep = (arr) =&gt; Array.isArray(arr)<br> ? arr.reduce( (a, b) =&gt; […a, …flattenDeep(b)] , [])<br> : [arr]<br> flattenDeep([1, [[2], [3, [4]], 5]])</p>
</li>
</ol>
<h4 id="53-_script的标签上都有什么属性">53. script的标签上都有什么属性</h4><p>type：表示编写代码使用的脚本语言的内容类型<br>src ：表示包含要执行代码的外部文件（带有src属性的元素中，不应该包含额外的js代码，如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略 。）<br>charset：设置字符集，例如utf-8等<br>defer：表示脚本可以延迟到文档全部被解析和显示之后再执行（defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行）<br>async： 表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。（async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行）</p>
<p>defer和async的区别：<br>  有了async属性，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行；<br>  有了defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。</p>
<h4 id="54-_jquery为什么可以一直链式调用">54. jquery为什么可以一直链式调用</h4><p>因为在每次使用完jquery的方法之后，都会返回一个当前的jquery对象，因此jquery可以一直链式调用</p>
<h4 id="55-_请简单实现一个下拉加载">55. 请简单实现一个下拉加载</h4><h4 id="56-_{}+[]与[]+{}分别返回什么，为什么">56. {}+[]与[]+{}分别返回什么，为什么</h4><h4 id="57-_addeventListener的第三个参数都可以是什么">57. addeventListener的第三个参数都可以是什么</h4><h4 id="58-_什么是Cookie_隔离？（或者说：请求资源的时候不要让它带cookie怎么做）">58. 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做）</h4><p>如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。</p>
<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，<br>这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。</p>
<p>同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，<br>提高了webserver的http请求的解析速度。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/29/js中高级相关问题/" data-id="cjz3fb0170034p0fyqrbidjso" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/算法相关/" class="article-date">
  <time datetime="2019-07-23T14:47:05.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/算法相关/">算法相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_实现一个快速排序（然后怎么优化）">1. 实现一个快速排序（然后怎么优化）</h4><h4 id="2-_深度遍历（递归以及非递归）">2. 深度遍历（递归以及非递归）</h4><h4 id="3-_广度遍历（递归以及非递归）">3. 广度遍历（递归以及非递归）</h4><h4 id="4-_递归的优化（尾递归）">4. 递归的优化（尾递归）</h4><h4 id="5-_数组的排序，去重">5. 数组的排序，去重</h4><h4 id="6-_实现一个js的深拷贝">6. 实现一个js的深拷贝</h4><h4 id="7-_动态规划法，0-1背包问题">7. 动态规划法，0-1背包问题</h4><h4 id="8-_红黑树，反转二叉树实现">8. 红黑树，反转二叉树实现</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/算法相关/" data-id="cjz3fazz5000jp0fywryitkc8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/算法/">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络基础相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/网络基础相关/" class="article-date">
  <time datetime="2019-07-23T14:28:55.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/网络基础相关/">网络基础相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_简述一下http1_1-1_2_3的区别">1. 简述一下http1 1.1 2 3的区别</h4><p><img src="https://github.com/zjzno1/img/blob/master/http.png?raw=true" alt=""><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2016/08/http.html</a></p>
<p>http1<br>支持get，post，head请求<br>缺点：</p>
<ol>
<li>每个tcp连接只能发送一个请求，发送完毕后，连接就关闭了，要想发送其他请求，需要再开一个tcp连接（解决方法是加一个<code>Connection: keep-alive</code>字段，但这不是标准字段，不同的实现行为可能不一致）</li>
</ol>
<p>http1.1</p>
<ol>
<li>引入持久连接，不用声明<code>Connection: keep-alive</code>，在客户端或者服务器一段时间发现对方没有活动，就可以主动关闭连接，不过规范做法是在最后一个请求发送<code>Connection: close</code>，明确要求关闭tcp连接</li>
<li>引入管道机制，即同一个tcp里面，客户端可以同时发送多个请求，这样进一步改进了http的效率（举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是服务器还是按照顺序，先回应A请求，完成后再回应B请求。）</li>
<li>新增了很多动词方法，例如put，delete，head，options，patch</li>
<li>客户端新增了host字段，用来指定服务器域名</li>
</ol>
<p>但是这样做仍然有缺点</p>
<ol>
<li>虽然是并发请求，但是响应却是要按照顺序接收，所以服务器只能处理完一个回应，才能处理下一个回应，如果当中一个回应特别慢，就会造成后面有许多回应要排队。</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量</li>
</ol>
<p>http2</p>
<ol>
<li>二进制分帧，每个桢包括一个帧头，里面有个很小标志，来区别是属于哪个流（减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。）</li>
<li>多路复用 （）</li>
<li>首部压缩（使用 HPACK 算法）</li>
<li>服务端推送 （服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。）<br>1）推送的资源可以由客户端缓存<br>2）推送的资源可以在不同的页面上重复使用<br>3）推送的资源可以与其他资源一起复用<br>4）推送的资源可以由服务器优先<br>5）推送的资源可以被客户拒绝</li>
</ol>
<p>http3<br>使用QUIC代替TCP<br>（1）对移动端切换网络体验更好<br>（2）解决了tcp的队头拥塞问题<br>（3）缩短连接建立时间</p>
<h4 id="2-_tcp三次握手，四次挥手">2. tcp三次握手，四次挥手</h4><h5 id="TCP_头部协议：">TCP 头部协议：</h5><p>| Flags:TCP 首部中有 6 个标志比特，它们中的多个可同时被设置为 1，主要是用于操控 TCP 的状态（URG，ACK，PSH，RST，SYN，FIN）</p>
<ul>
<li>ACK ： TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1</li>
<li>SYN(SYNchronization) ： 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。</li>
<li>FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。</li>
</ul>
<h5 id="三次握手">三次握手</h5><ul>
<li>第一次握手：建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；</li>
<li>第三次握手：客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。</li>
<li>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是 TCP 三次握手的总体介绍。</li>
</ul>
<h5 id="四次分手">四次分手</h5><p>当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的“四次分手”。</p>
<ul>
<li>第一次分手：主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number 和 Acknowledgment Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；</li>
<li>第二次分手：主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我“同意”你的关闭请求；</li>
<li>第三次分手：主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；</li>
<li>第四次分手：主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。</li>
</ul>
<h4 id="3-_https的实现方式（详细过程）,里面涉及到的加密算法都有哪些">3. https的实现方式（详细过程）,里面涉及到的加密算法都有哪些</h4><h5 id="HTTP传输协议的缺点">HTTP传输协议的缺点</h5><p>（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。<br>（2） 篡改风险（tampering）：第三方可以修改通信内容。<br>（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。<br>因此需要加密传输避免以上缺点</p>
<h5 id="https使用SSL/TLS">https使用SSL/TLS</h5><p>目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。<br>TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。</p>
<h5 id="HTTP协议和SLL/TLS协议是如何结合使用的">HTTP协议和SLL/TLS协议是如何结合使用的</h5><h4 id="4-_OSI七层模型">4. OSI七层模型</h4><ul>
<li>应用层(Application) 提供网络与用户应用软件之间的接口服务</li>
<li>表示层(Presentation) 提供格式化的表示和转换数据服务，如加密和压缩</li>
<li>会话层(Session) 提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制</li>
<li>传输层(Transimission) 提供建立、维护和取消传输连接功能，负责可靠地传输数据(PC)</li>
<li>网络层(Network) 处理网络间路由，确保数据及时传送(路由器)</li>
<li>数据链路层(DataLink) 负责无错传输数据，确认帧、发错重传等(交换机)</li>
<li>物理层(Physics) 提供机械、电气、功能和过程特性(网卡、网线、双绞线、同轴电缆、中继器)</li>
</ul>
<h4 id="5-_DNS请求路径">5. DNS请求路径</h4><h4 id="6-_TCP/UDP的区别，怎么实现可靠UDP">6. TCP/UDP的区别，怎么实现可靠UDP</h4><ul>
<li>TCP 是面向连接(Connection oriented)的协议，UDP 是无连接(Connection less)协议；TCP 用三次握手建立连接：1) Client 向 server 发送 SYN；2) Server 接收到 SYN，回复 Client 一个 SYN-ACK；3) Client 接收到 SYN_ACK，回复 Server 一个 ACK。到此，连接建成。UDP 发送数据前不需要建立连接。</li>
<li>TCP 可靠，UDP 不可靠；TCP 丢包会自动重传，UDP 不会。</li>
<li>TCP 有序，UDP 无序；消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP 会对其进行重排序，UDP 不会。</li>
<li>TCP 无界，UDP 有界；TCP 通过字节流传输，UDP 中每一个包都是单独的。</li>
<li>TCP 有流量控制（拥塞控制），UDP 没有；主要靠三次握手实现。</li>
<li>TCP 传输慢，UDP 传输快；因为 TCP 需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用 UDP。</li>
<li>TCP 是重量级的，UDP 是轻量级的；TCP 要建立连接、保证可靠性和有序性，就会传输更多的信息，如 TCP 的包头比较大。</li>
<li>TCP 的头部比 UDP 大；TCP 头部需要 20 字节，UDP 头部只要 8 个字节</li>
</ul>
<h4 id="7-_web开发中会话的跟踪方法有哪些">7. web开发中会话的跟踪方法有哪些</h4><p>当用户发出请求时，服务器就会做出响应，客户端与服务器之间的联系是离散的、非连续的。当用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。</p>
<p>1.Cookie：<br>可以使用 cookie 存储购物会话的 ID；在后续连接中，取出当前的会话 ID，并使用这个 ID 从服务器上的查找表（lookup table）中提取出会话的相关信息。 以这种方式使用 cookie 是一种绝佳的解决方案，也是在处理会话时最常使用的方式。但是，sevlet 中最好有一种高级的 API 来处理所有这些任务，以及下面这些冗长乏味的任务：从众多的其他cookie中（毕竟可能会存在许多cookie）提取出存储会话标识符的 cookie；确定空闲会话什么时候过期，并回收它们；将散列表与每个请求关联起来；生成惟一的会话标识符.</p>
<p>2.URL 重写：<br>采用这种方式时，客户程序在每个URL的尾部添加一些额外数据。这些数据标识当前的会话，服务器将这个标识符与它存储的用户相关数据关联起来。 URL重写是比较不错的会话跟踪解决方案，即使浏览器不支持 cookie 或在用户禁用 cookie 的情况下，这种方案也能够工作。<br>URL 重写具有 cookie 所具有的同样缺点，也就是说，服务器端程序要做许多简单但是冗长乏味的处理任务。即使有高层的 API 可以处理大部分的细节，仍须十分小心每个引用你的站点的 URL ，以及那些返回给用户的 URL。即使通过间接手段，比如服务器重定向中的 Location 字段，都要添加额外的信息。这种限制意味着，在你的站点上不能有任何静态 HTML 页面（至少静态页面中不能有任何链接到站点动态页面的链接）。因此，每个页面都必须使用 servlet 或 JSP 动态生成。即使所有的页面都动态生成，如果用户离开了会话并通过书签或链接再次回来，会话的信息也会丢失，因为存储下来的链接含有错误的标识信息。</p>
<p>3.隐藏的表单域：<br>HTML 表单中可以含有如下的条目：<input type="hidden" name="session" value="a1234"><br>这个条目的意思是：在提交表单时，要将指定的名称和值自动包括在 GET 或 POST 数据中。这个隐藏域可以用来存储有关会话的信息，但它的主要缺点是：仅当每个页面都是由表单提交而动态生成时，才能使用这种方法。单击常规的超文本链接并不产生表单提交，因此隐藏的表单域不能支持通常的会话跟踪，只能用于一系列特定的操作中，比如在线商店的结账过程。</p>
<p>4.session:<br>信息保存在服务器端<br>使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p>
<h4 id="8-_http_method">8. http method</h4><p>1 GET 请求指定的页面信息，并返回实体主体。<br>2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。<br>4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。<br>5 DELETE 请求服务器删除指定的页面。<br>6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>7 OPTIONS 允许客户端查看服务器的性能。<br>8 TRACE 回显服务器收到的请求，主要用于测试或诊断。<br>9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。</p>
<h4 id="9-_js跨域通信（跨域产生的原因，常见解决方法及原理，手动实现个jsonp）">9. js跨域通信（跨域产生的原因，常见解决方法及原理，手动实现个jsonp）</h4><h4 id="10-_http常用状态码_101，200，301，302，304，401，403，404，500，502等">10. http常用状态码 101，200，301，302，304，401，403，404，500，502等</h4><ul>
<li>1xx Informational(信息性状态码) 接受的请求正在处理</li>
<li>2xx Success(成功状态码) 请求正常处理完毕</li>
<li>3xx Redirection(重定向状态码) 需要进行附加操作一完成请求</li>
<li>4xx Client Error (客户端错误状态码) 服务器无法处理请求</li>
<li>5xx Server Error(服务器错误状态码) 服务器处理请求出错</li>
</ul>
<p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源<br>500 internal sever error，表示服务器端在执行请求时发生了错误</p>
<h4 id="11-_restful是什么，怎么使用">11. restful是什么，怎么使用</h4><p>Restful是一种架构设计风格，提供了设计原则和约束条件，而不是架构，而满足这些约束条件和原则的应用程序或设计就是 Restful架构或服务。<br>主要的设计原则：<br>  资源与URI：网络上所有的资源都有一个资源标志符（URI）。URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联<br>  统一资源接口(HTTP方法如GET，PUT和POST)：不论什么样的资源，都是通过使用相同的接口进行资源的访问<br>  资源的表述：通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。<br>  资源的链接：<br>  状态的转移：<br>RESTful的核心就是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作</p>
<h4 id="12-_从浏览器输入一个url，到页面完成的加载的过程（尽可能详细的描述）">12. 从浏览器输入一个url，到页面完成的加载的过程（尽可能详细的描述）</h4><ul>
<li>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来</li>
<li>接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li>
<li>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据</li>
<li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</li>
<li>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li>
<li>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li>
<li>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</li>
<li>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</li>
<li>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li>
<li>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</li>
</ul>
<h4 id="13-_正向代理，反向代理，透明代理">13. 正向代理，反向代理，透明代理</h4><h4 id="14-_请求时浏览器缓存_from_memory_cache_和_from_disk_cache_的依据是什么，哪些数据什么时候存放在_Memory_Cache_和_Disk_Cache中">14. 请求时浏览器缓存 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中</h4><ul>
<li>200 form memory cache 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。（脚本、字体、图片）</li>
<li>200 from disk cache 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。（非脚本，如css）</li>
</ul>
<p>一般样式表会缓存在磁盘中，不会缓存到内存中，因为css样式加载一次即可渲染出页面。但是脚本可能会随时执行，如果把脚本存在磁盘中，在执行时会把该脚本从磁盘中提取到缓存中来，这样的IO开销比较大，有可能会导致浏览器失去响应。</p>
<p>例如：图片<br>访问-&gt; 200 -&gt; 退出浏览器<br>再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache)</p>
<p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="external">深入理解浏览器的缓存机制</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/网络基础相关/" data-id="cjz3fazz10009p0fyluh0txb7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http-https/">http/https</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/网络相关/">网络相关</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node相关试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/node相关试题/" class="article-date">
  <time datetime="2019-07-23T14:03:27.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/node相关试题/">node相关试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_node什么时候内存溢出（泄露），怎么避免（解决）">1. node什么时候内存溢出（泄露），怎么避免（解决）</h4><p>原因：<br>在 Node 中，V8引擎有默认限制内存大小，通过 JavaScript 使用内存时只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），如果项目过于庞大，就会造成内存溢出。<br>解决方法：<br>（1）可以在Node启动的时候，传递–max-old-space-size或–max-new-space-size来调整内存大小的使用限制。</p>
<pre><code>node --<span class="built_in">max</span>-old-space-<span class="built_in">size</span>=<span class="number">1700</span> test.js <span class="comment">// 单位为MB</span>
<span class="comment">// 或者</span>
node --<span class="built_in">max</span>-<span class="keyword">new</span>-space-<span class="built_in">size</span>=<span class="number">1024</span> test.js <span class="comment">// 单位为KB</span>
</code></pre><p>上述参数在V8初始化时生效，一旦生效就不能再动态改变。如果遇到 Node 无法分配足够内存给 JavaScript 的情况，可以用这个办法来放宽V8默认的内存限制</p>
<h4 id="2-_node中间件（中间件是什么（定义），中间件原理是什么），为什么引入中间件，有没有写过或者使用过中间件，它解决了什么问题">2. node中间件（中间件是什么（定义），中间件原理是什么），为什么引入中间件，有没有写过或者使用过中间件，它解决了什么问题</h4><h5 id="中间件定义（是什么）：">中间件定义（是什么）：</h5><p>中间件就是请求req和响应res之间的一个应用，本质就是一个函数</p>
<p>详细描述：<br>请求浏览器向服务器发送一个请求后，服务器直接通过request定位属性的方式得到通过request携带过去的数据，就是用户输入的数据和浏览器本身的数据信息，这中间就一定有一个函数将这些数据分类做了处理，最后让<code>request（是不是response存疑）</code>对象调用使用，这个处理函数就是我们所所得中间插件</p>
<h5 id="中间件原理（app-use的原理）：">中间件原理（app.use的原理）：</h5><p>作用就是把我们用app.use注册的所有中间件和路由方法交给Router类来处理。</p>
<h5 id="中间件分类">中间件分类</h5><p>应用级中间件 ()<br>路由级中间件 (router.use, router.get, router.post等)<br>错误处理中间件 ()<br>内置中间件 （app.static）<br>第三方中间件 </p>
<h5 id="写过（或者使用过）什么中间件，解决了什么问题">写过（或者使用过）什么中间件，解决了什么问题</h5><p>写过也用过一些中间件，例如最常用的路由级中间件，首先根据页面url的不同，走到了不同的路由中间件中；在单页面应用中，还解决了单页面应用刷新时使用history下的rewrites进行重定向的问题。<br>再比如其他中间件，还用到过解析cookie，记录日志等中间件<br>自己也写过设置缓存的中间件等</p>
<pre><code>res.<span class="built_in">set</span>Header(<span class="string">"Expires"</span>, nowTime.<span class="keyword">to</span>UTCString());
res.<span class="built_in">set</span>Header(<span class="string">"Cache-Control"</span>, <span class="string">"max-age="</span> + <span class="keyword">max</span>Age);
</code></pre><h4 id="3-_node的event-loop（）">3. node的event-loop（）</h4><p>Node 中的 Event loop 和浏览器中的不相同。</p>
<p>Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行</p>
<p>┌───────────────────────┐<br>┌─&gt;│        timers         │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     I/O callbacks     │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>│  │     idle, prepare     │<br>│  └──────────┬────────────┘      ┌───────────────┐<br>│  ┌──────────┴────────────┐      │   incoming:   │<br>│  │         poll          │&lt;──connections───     │<br>│  └──────────┬────────────┘      │   data, etc.  │<br>│  ┌──────────┴────────────┐      └───────────────┘<br>│  │        check          │<br>│  └──────────┬────────────┘<br>│  ┌──────────┴────────────┐<br>└──┤    close callbacks    │<br>   └───────────────────────┘</p>
<p>timer<br>timers 阶段会执行 setTimeout 和 setInterval<br>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。<br>下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为1。<br><strong>I/O </strong><br>I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调<br>idle, prepare<br>idle, prepare 阶段内部实现<br>poll<br>poll 阶段很重要，这一阶段中，系统会做两件事情</p>
<p>执行到点的定时器<br>执行 poll 队列中的事件</p>
<p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p>
<p>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制<br>如果 poll 队列为空，会有两件事发生</p>
<p>如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate<br>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调</p>
<p>如果有别的定时器需要被执行，会回到 timer 阶段执行回调。<br>check<br>check 阶段执行 setImmediate<br>close callbacks<br>close callbacks 阶段执行 close 事件<br>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p>
<pre><code>setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);
}, <span class="number">0</span>);
setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);
})
<span class="regexp">//</span> 这里可能会输出 setTimeout，setImmediate
<span class="regexp">//</span> 可能也会相反的输出，这取决于性能
<span class="regexp">//</span> 因为可能进入 event <span class="keyword">loop</span> 用了不到 <span class="number">1</span> 毫秒，这时候会执行 setImmediate
<span class="regexp">//</span> 否则会执行 setTimeout
</code></pre><p>复制代码当然在这种情况下，执行顺序是相同的</p>
<pre><code>var fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)

fs.readFile(__filename, <span class="function"><span class="params">()</span> =&gt;</span> {
    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
        <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);
    }, <span class="number">0</span>);
    setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> {
        <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);
    });
});
<span class="regexp">//</span> 因为 readFile 的回调在 poll 中执行
<span class="regexp">//</span> 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调
<span class="regexp">//</span> 再去 timer 阶段执行 setTimeout
<span class="regexp">//</span> 所以以上输出一定是 setImmediate，setTimeout
</code></pre><p>复制代码上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。</p>
<pre><code>setTimeout(()=&gt;{
    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)

    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)
    })
}, <span class="number">0</span>)

setTimeout(()=&gt;{
    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)

    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)
    })
}, <span class="number">0</span>)

<span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span>
<span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span>
<span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span>
<span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span>
</code></pre><p>复制代码Node 中的 process.nextTick 会先于其他 microtask 执行。</p>
<pre><code>setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {
<span class="built_in">console</span>.log(<span class="string">"timer1"</span>);

Promise.resolve().<span class="keyword">then</span>(function() {
    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);
});
}, <span class="number">0</span>);

process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> {
<span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);
});
<span class="regexp">//</span> nextTick, timer1, promise1
</code></pre><h4 id="4-_express和koa的对比，各自的优缺点">4. express和koa的对比，各自的优缺点</h4><ol>
<li><p>体积不同<br>Express较大而全，主要基于Connect中间件框架，功能丰富，随取随用，并且框架自身封装了大量便利的功能，比如路由、视图处理等等<br>koa体积更小，主要基于co中间件框架，框架自身并没集成太多功能，大部分功能需要用户自行require中间件去解决。</p>
</li>
<li><p>中间件不同<br>（1） 调用方式不同<br>express是使用了callback进行回调，koa使用了ES6 generator特性，co框架会把所有generator的返回封装成为Promise对象<br>koa的中间件模式与express的是不一样的，koa是洋葱型，express是直线型<code>存疑</code></p>
</li>
</ol>
<h4 id="5-_洋葱模型">5. 洋葱模型</h4><pre><code><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);
<span class="keyword">const</span> app = <span class="keyword">new</span> Koa();

<span class="comment">// logger</span>

app.use(<span class="keyword">async</span> (ctx, next) =&gt; {
    <span class="built_in">console</span>.log(<span class="number">1</span>);
    <span class="keyword">await</span> next();
    <span class="built_in">console</span>.log(<span class="number">2</span>);
    <span class="keyword">const</span> rt = ctx.response.get(<span class="string">'X-Response-Time'</span>);
    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">${ctx.method}</span> <span class="subst">${ctx.url}</span> - <span class="subst">${rt}</span>`</span>);
});

<span class="comment">// x-response-time</span>

app.use(<span class="keyword">async</span> (ctx, next) =&gt; {
    <span class="built_in">console</span>.log(<span class="number">3</span>);
    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();
    <span class="keyword">await</span> next();
    <span class="built_in">console</span>.log(<span class="number">4</span>);
    <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;
    ctx.set(<span class="string">'X-Response-Time'</span>, <span class="string">`<span class="subst">${ms}</span>ms`</span>);
});

<span class="comment">// response</span>

app.use(<span class="keyword">async</span> ctx =&gt; {
    <span class="built_in">console</span>.log(<span class="number">5</span>);
    ctx.body = <span class="string">'Hello World'</span>;
});

app.listen(<span class="number">3000</span>);  <span class="comment">// 访问localhost:3000 得到 1 3 5 4 2</span>
</code></pre><p>koa的洋葱模型，在遇到next的时候会把当前中间件压栈，执行下一个中间件，一直到没有next或者next为空，然后在一个个按照先进后出的原则出栈</p>
<h4 id="6-_v8引擎相关原理与知识">6. v8引擎相关原理与知识</h4><h4 id="7-_有过哪些node的原生api，是怎么和php以及java系统交互的">7. 有过哪些node的原生api，是怎么和php以及java系统交互的</h4><p>fs、path、http(我们内部封装了h-request的npm包，在请求不同系统时，附带不同的参数)</p>
<h4 id="8-_node的守护进程，（node集群是怎么管理的，怎么收集日志的）">8. node的守护进程，（node集群是怎么管理的，怎么收集日志的）</h4><p>node的守护进程<br>pm2<br>node集群管理<br>上线代码会分别在线上node机器上全部上去，然后根据nginx做负载均衡，如果其中一台机器一直重启，在重启到一定次数后会终止重启，然后发邮件以及短信通知。<br>日志收集<br>从三个纬度收集日志</p>
<ol>
<li>首先用leo收集打到nginx的url，用来收集一些例如url，cookie，referrer等信息，已复现用户的操作路径</li>
<li>在编写代码时，使用try chach或者if代码块，如果走入异常情况，发送sentry记录日志</li>
<li>node代码中，在异常情况下，同时可以记录更为详细的log在node工程的同级目录下<h4 id="9-_node怎么上线（上线流程），怎么监控">9. node怎么上线（上线流程），怎么监控</h4></li>
</ol>
<h4 id="10-_npm_install后是怎么执行的">10. npm install后是怎么执行的</h4><p>首先根据package.json的dependencies和devDependencies去下载引用的包放在package.json的同级目录node_modules下。如果你没有设置npm的源，那默认到npm的官方网址下载，如果有设置其他源，例如淘宝源或者公司内部源，那就会去设置的源去下载。<br>npm install -g 下载到全局<br>npm install –save 保存到dependencies<br>npm install –save-dev 保存到devDependencies</p>
<h4 id="11-_node有哪些定时功能">11. node有哪些定时功能</h4><p>setTimeout/clearTimeout, setInterval/clearInterval, setImmediate/clearImmediate, process.nextTick</p>
<h4 id="12-_fs-watch和fs-watchFile有什么区别，怎么应用?">12.  fs.watch和fs.watchFile有什么区别，怎么应用?</h4><p>二者主要用来监听文件变动．fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统; fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不是实时机制．</p>
<h4 id="13-_实现一个简单的http服务器">13. 实现一个简单的http服务器</h4><pre><code>var <span class="keyword">http</span> = <span class="built_in">require</span>(<span class="string">'http'</span>);<span class="comment"> // 加载http模块</span>
<span class="keyword">http</span>.createServer(<span class="function"><span class="keyword">function</span>(<span class="title">req</span>, <span class="title">res</span>) {</span>
    res.writeHead(<span class="number">200</span>, {<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>});<span class="comment"> // 200代表状态成功, 文档类型是给浏览器识别用的</span>
    res.<span class="built_in">write</span>(<span class="string">'&lt;meta charset="UTF-8"&gt; &lt;h1&gt;我是标题啊！&lt;/h1&gt; &lt;font color="red"&gt;这么原生，初级的服务器，下辈子能用着吗?!&lt;/font&gt;'</span>);<span class="comment"> // 返回给客户端的html数据</span>
    res.<span class="keyword">end</span>();<span class="comment"> // 结束输出流</span>
}).listen(<span class="number">3000</span>);<span class="comment"> // 绑定3ooo, 查看效果请访问 http://localhost:3000</span>
</code></pre><h4 id="14-_child-process相关">14. child-process相关</h4><ol>
<li>为什么需要child-process?<br>参考答案: node是异步非阻塞的，这对高并发非常有效．可是我们还有其它一些常用需求，比如和操作系统shell命令交互，调用可执行文件，创建子进程进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的．child-process顾名思义，就是把node阻塞的工作交给子进程去做．</li>
<li>exec,execFile,spawn和fork都是做什么用的?<br>参考答案: exec可以用操作系统原生的方式执行各种命令，如管道 cat ab.txt | grep hello; execFile是执行一个文件; spawn是流式和操作系统进行交互; fork是两个node程序(javascript)之间时行交互.</li>
<li>实现一个简单的命令行交互程序?<br>参考答案: 那就用spawn吧.</li>
</ol>
<h4 id="15-_怎样充分利用多个CPU?">15. 怎样充分利用多个CPU?</h4><p>每个进程各使用一个CPU，，以此实现多核CPU的利用。Node提供了child_process模块，并且也提供了fork()方法来实现进程的复制(Node复制进程需要不小于10M的内存和不小于30ms的时间)。<br>解决方案就是Master-Worker模式（又称为主从模式），通过IPC通道实现主从进程间的通信，通信的目的是为了让不同的进程能够互相访问资源并进行协调工作</p>
<h4 id="16-_程序总是崩溃，怎样找出问题在哪里?">16. 程序总是崩溃，怎样找出问题在哪里?</h4><p>参考答案: 1) node –prof 查看哪些函数调用次数多 2) memwatch和heapdump获得内存快照进行对比，查找内存溢出</p>
<h4 id="17-_有哪些常用方法可以防止程序崩溃?">17. 有哪些常用方法可以防止程序崩溃?</h4><p>1) try-catch-finally<br>2) EventEmitter/Stream error事件处理<br>3) domain统一控制<br>4) jshint静态检查<br>5) jasmine/mocha进行单元测试</p>
<h4 id="18-_怎样调试node程序">18. 怎样调试node程序</h4><p>node –debug app.js 和node-inspector</p>
<h4 id="19-_typeScript的优点（具体举例）">19. typeScript的优点（具体举例）</h4><p>两大特性：</p>
<ol>
<li>给JavaScript加上可选的类型系统，很多事情是只有静态类型才能做的，给JavaScript加上静态类型后，就能将调试从运行期提前到编码期，诸如类型检查、越界检查这样的功能才能真正发挥作用。TypeScript的开发体验远远超过以往纯JavaScript的开发体验，无需运行程序即可修复潜在bug。</li>
<li>另一个特性是支持未来的ES 6甚至ES 7，最近的更新都与此有关。在TypeScript中，你可以直接使用ES 6的最新特性，在编译时它会自动编译到ES 3或ES 5。</li>
</ol>
<p>优点细节浏览：</p>
<ol>
<li>TS是一个应用程序级的JavaScript开发语言。</li>
<li>TS是JavaScript的超集，可以编译成纯JavaScript。</li>
<li>TS跨浏览器、跨操作系统、跨主机，开源。</li>
<li>TS始于JS，终于JS。遵循JavaScript的语法和语义，方便了无数的JavaScript开发者。</li>
<li>TS可以重用现有的JavaScript代码，调用流行的JavaScript库。</li>
<li>TS可以编译成简洁、简单的JavaScript代码，在任意浏览器、Node.js或任何兼容ES3的环境上运行。</li>
<li>TypeScript比JavaScript更具开发效率，包括：静态类型检查、基于符号的导航、语句自动完成、代码重构等。</li>
<li>TS提供了类、模块和接口，更易于构建组件。</li>
</ol>
<h4 id="20-_介绍一下对nodejs的异步IO原理，以及内部线程池相关内容">20. 介绍一下对nodejs的异步IO原理，以及内部线程池相关内容</h4><h4 id="21-_nodejs的进程维护有了解过么">21. nodejs的进程维护有了解过么</h4><h4 id="22-_nodejs的0秒重载">22. nodejs的0秒重载</h4><h4 id="23-_express运行流程与原理">23. express运行流程与原理</h4><h4 id="24-_模版引擎是怎么渲染到页面上的">24. 模版引擎是怎么渲染到页面上的</h4><h4 id="25-_express中的路由规则">25. express中的路由规则</h4><h4 id="26-_node性能优化">26. node性能优化</h4><h4 id="27-_说一下node里对Buffer数据类型的认识，对于初始化的Buffer，可以实现增加长度吗">27. 说一下node里对Buffer数据类型的认识，对于初始化的Buffer，可以实现增加长度吗</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/node相关试题/" data-id="cjz3fb002001up0fygsxytkr3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node相关试题/">node相关试题</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue相关试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/vue相关试题/" class="article-date">
  <time datetime="2019-07-23T13:34:13.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/vue相关试题/">vue相关试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="1-_vue的生命周期及相关概念（哪个周期在干什么）">1. vue的生命周期及相关概念（哪个周期在干什么）</h4><h6 id="new_vue()">new vue()</h6><p>创建vue实例<br>初始化event和lifecycle</p>
<h6 id="beforeCreate">beforeCreate</h6><p>完成实例初始化，初始化非响应式变量<br>this指向创建的实例；<br>可以在这加个loading事件；<br>data computed watch methods上的方法和数据均不能访问</p>
<h6 id="created">created</h6><p>实例创建完成<br>完成数据(data props computed)的初始化 导入依赖项。<br>可访问data computed watch methods上的方法和数据<br>未挂载DOM,不能访问$el,$ref为空数组<br>可在这结束loading，还做一些初始化，实现函数自执行,<br>可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。<br>若在此阶段进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中</p>
<h6 id="beforeMount">beforeMount</h6><p>有了el,编译了template|/outerHTML<br>能找到对应的template,并编译成render函数</p>
<h6 id="mounted">mounted</h6><p>完成创建vm.$el，和双向绑定，<br>完成挂载DOM 和渲染;可在mounted钩子对挂载的dom进行操作<br>即有了DOM 且完成了双向绑定 可访问DOM节点,$ref<br>可在这发起后端请求，拿回数据，配合路由钩子做一些事情；<br>可对DOM 进行操作</p>
<h6 id="beforeUpdate">beforeUpdate</h6><p>数据更新之前<br>可在更新前访问现有的DOM,如手动移除添加的事件监听器；</p>
<h6 id="updated">updated</h6><p>完成虚拟DOM的重新渲染和打补丁；<br>组件DOM 已完成更新；<br>可执行依赖的dom 操作<br>注意：不要在此函数中操作数据，会陷入死循环的。</p>
<h6 id="beforeDistory">beforeDistory</h6><p>在执行app.$destroy()之前<br>可做一些删除提示，如：你确认删除XX吗？<br>可用于销毁定时器，解绑全局时间 销毁插件对象</p>
<h6 id="destroyed">destroyed</h6><p>当前组件已被删除，销毁监听事件 组件 事件 子实例也被销毁<br>这时组件已经没有了，你无法操作里面的任何东西了。</p>
<h5 id="在keep_alive组件中，还有一下两个周期">在<code>keep alive</code>组件中，还有一下两个周期</h5><h6 id="activated">activated</h6><p>在使用vue-router时有时需要使用<keep-alive></keep-alive>来缓存组件状态，这个时候created钩子就不会被重复调用了，<br>如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发</p>
<h6 id="deactivated">deactivated</h6><p>keep-alive 组件被移除时使用</p>
<h4 id="2-_vue-model_怎么实现双向数据绑定">2. vue-model 怎么实现双向数据绑定</h4><p>Vue数据双向绑定（即数据响应式），是利用了Object.defineProperty()这个方法重新定义了对象获取属性值get和设置属性值set的操作来实现的。<br>数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发生变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。</p>
<h4 id="3-_组件之间的通信(传值)有几种实现方式">3. 组件之间的通信(传值)有几种实现方式</h4><ol>
<li>父组件向子组件传值props，子组件向父组件传值$emit</li>
<li>$emit/$on</li>
<li>vuex</li>
<li>$attrs/$listeners</li>
<li>provide/inject</li>
<li>$parent / $children与 ref</li>
</ol>
<h4 id="4-_vue和其他框架相比，有什么优缺点">4. vue和其他框架相比，有什么优缺点</h4><h4 id="5-_vue3-0（相关）和2-0比较，有什么优缺点">5. vue3.0（相关）和2.0比较，有什么优缺点</h4><p>Evan You（尤雨溪）在2018年11月16日早上在 Vue Toronto 的主题演讲中预演了 Vue 3.0的新特性 。利用现代浏览器支持的新功能，Vue 3 将成为我们已经了解和喜爱的 Vue.js 强大的的改进版本。</p>
<p>大概可以分为：</p>
<ol>
<li>更快</li>
<li>更小</li>
<li>更易于维护</li>
<li>更多的原生支持</li>
<li>更易于开发使用</li>
</ol>
<p>1、虚拟 DOM 重写，mounting和patching的速度提高100％<br>2、更多的编译时的提示来减少运行时的开销<br>3、组件快速路径+单个调用+子类型检测</p>
<ul>
<li>跳过不必要的条件分支</li>
<li>JS引擎更容易优化<br>4、优化插槽的生成</li>
<li>确保实例正确的跟踪依赖关系</li>
<li>避免不必要的父子组件重新渲染<br>5、静态树提升</li>
<li>跳过修补整棵树，从而降低渲染成本</li>
<li>即使多次出现也能正常工作<br>6、静态属性提升</li>
<li>跳过不会改变节点的修补过程，但是它的子组件会保持修补过程<br>7、内联的事件提升</li>
<li>避免因为不同的内联函数标识而导致的不必要的重新渲染<br>8、基于Proxy的观察者机制，全语言覆盖+更好的性能</li>
<li>目前vue使用的是Object.defineProperty 的 getter 和 setter</li>
<li>组件实例初始化的速度提高100％</li>
<li>使用Proxy节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容</li>
<li>为了继续支持 IE11，Vue 3 将发布一个支持旧观察者机制和新 Proxy 版本的构建</li>
</ul>
<h5 id="更小">更小</h5><p>更友好的tree-shaking<br>新的core runtime 压缩后大概 10kb</p>
<h5 id="更加可维护">更加可维护</h5><p>Flow -&gt; TypeScript<br>包的解耦<br>编译器重写</p>
<pre><code>-<span class="ruby"> 可插拔的架构
</span>-<span class="ruby"> 提供更强大的<span class="constant">IDE</span>支持来作为基础设施</span>
</code></pre><h5 id="提供更方便的原生支持">提供更方便的原生支持</h5><p>运行时内核也将与平台无关，使得 Vue 可以更容易地与任何平台（例如Web，iOS或Android）一起使用</p>
<h5 id="更方便的开发">更方便的开发</h5><p>暴露响应式的api</p>
<h4 id="6-_vue里this的指向">6. vue里this的指向</h4><p>在根组件中<br>this 指向  vue实例<br>this.$el 指向绑定的根元素</p>
<p>在子组件中<br>this  指向 Vue 子组件的实例<br>this.$el  指向 当前组件的DOM元素</p>
<h4 id="7-_v-for的时候为什么要使用key，优缺点什么">7. v-for的时候为什么要使用key，优缺点什么</h4><p>vue和react都是采用diff算法来对比新旧虚拟节点，从而更新节点。在vue的diff函数中（建议先了解一下diff算法过程）。<br>在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个map映射，另一种是遍历查找。相比而言。map映射的速度更快。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有唯一 id</p>
<p>key只在查找复用节点的时候起到了查找作用</p>
<p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<h4 id="8-_vue的diff算法">8. vue的diff算法</h4><h4 id="9-_vue怎么更新的视图，视图怎么更新vue">9. vue怎么更新的视图，视图怎么更新vue</h4><h4 id="10-_vue中的on可以监听多个事件嘛">10. vue中的on可以监听多个事件嘛</h4><p>可以。<br>vm.$on( event, callback )<br>用法：<br>监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。（$emit和$on必须在一个公共实例上才能触发）</p>
<h4 id="11-_vuex相关，（action和mutations有什么区别）">11. vuex相关，（action和mutations有什么区别）</h4><p>mutations 同步更新store里的state<br>action 异步更新store里的state</p>
<h4 id="12-_vue-router相关（vue-router的生命周期，动态加载，传值，实现原理，全局守卫_https://router-vuejs-org/zh/_https://blog-csdn-net/yelin042/article/details/79932606）">12. vue-router相关（vue-router的生命周期，动态加载，传值，实现原理，全局守卫 <a href="https://router.vuejs.org/zh/" target="_blank" rel="external">https://router.vuejs.org/zh/</a>  <a href="https://blog.csdn.net/yelin042/article/details/79932606）" target="_blank" rel="external">https://blog.csdn.net/yelin042/article/details/79932606）</a></h4><h4 id="13-_keep-alive相关">13. keep-alive相关</h4><h4 id="14-_vue的渲染过程，vue组件的渲染过程">14. vue的渲染过程，vue组件的渲染过程</h4><h4 id="15-_vue中的data可以是个对象吗，为什么">15. vue中的data可以是个对象吗，为什么</h4><h4 id="16-_vue里的$this-nextTick();">16. vue里的$this.nextTick();</h4><p>nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。<br>在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。<br>对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout</p>
<pre><code><span class="keyword">if</span> (typeof setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) {
    macroTimerFunc = () =&gt; {
        setImmediate(flushCallbacks)
    }
    } <span class="keyword">else</span> <span class="keyword">if</span> (
    typeof MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;
    (isNative(MessageChannel) ||
        <span class="comment">// PhantomJS</span>
        MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)
    ) {
    <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()
    <span class="keyword">const</span> port = channel.port2
    channel.port1.onmessage = flushCallbacks
    macroTimerFunc = () =&gt; {
        port.postMessage(<span class="number">1</span>)
    }
    } <span class="keyword">else</span> {
    <span class="comment">/* istanbul ignore next */</span>
    macroTimerFunc = () =&gt; {
        setTimeout(flushCallbacks, <span class="number">0</span>)
    }
}
</code></pre><p>nextTick 同时也支持 Promise 的使用，会判断是否实现了 Promise</p>
<pre><code><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>{
    <span class="keyword">let</span> _resolve
    <span class="comment">// 将回调函数整合进一个数组中</span>
    callbacks.push(() =&gt; {
        <span class="keyword">if</span> (cb) {
        <span class="keyword">try</span> {
            cb.call(ctx)
        } <span class="keyword">catch</span> (e) {
            handleError(e, ctx, <span class="string">'nextTick'</span>)
        }
        } <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) {
        _resolve(ctx)
        }
    })
    <span class="keyword">if</span> (!pending) {
        pending = <span class="literal">true</span>
        <span class="keyword">if</span> (useMacroTask) {
        macroTimerFunc()
        } <span class="keyword">else</span> {
        microTimerFunc()
        }
    }
    <span class="comment">// 判断是否可以使用 Promise </span>
    <span class="comment">// 可以的话给 _resolve 赋值</span>
    <span class="comment">// 这样回调函数就能以 promise 的方式调用</span>
    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve =&gt; {
        _resolve = resolve
        })
    }
}
</code></pre><p><a href="https://juejin.im/post/5d41eec26fb9a06ae439d29f?utm_source=gold_browser_extension#heading-16" target="_blank" rel="external">13道可以举一反三的Vue面试题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/vue相关试题/" data-id="cjz3fazzv001lp0fyj6yijvhu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/设计模式/" class="article-date">
  <time datetime="2019-07-23T13:33:51.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/设计模式/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>二、结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>三、行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>1、工厂方法模式：</p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。</p>
<p>工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，这就用到工厂方法模式。</p>
<p>创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
<p>2、抽象工厂模式：</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。<br>3、单例模式：</p>
<p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
<p>（1）某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p>
<p>（2）省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p>
<p>（3）有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<p>4、建造者模式：</p>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>5、原型模式：</p>
<p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类。</p>
<p>6、适配器模式：</p>
<p>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<p>7、装饰器模式：</p>
<p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p>8、代理模式：</p>
<p>代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。</p>
<p>9、外观模式：</p>
<p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<p>10、桥接模式：</p>
<p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样。</p>
<p>JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。</p>
<p>11、组合模式：</p>
<p>组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便。使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p>
<p>12、享元模式：</p>
<p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p>13、策略模式：</p>
<p>策略模式定义了一系列算法，并将每个算法封装起来，使其可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数。</p>
<p>14、模板方法模式：</p>
<p>一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用。</p>
<p>15、观察者模式：<br>观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。</p>
<p>其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。</p>
<p>16、迭代子模式：</p>
<p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。</p>
<p>17、责任链模式：</p>
<p>责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。</p>
<p>18、命令模式：</p>
<p>命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开。</p>
<p>19、备忘录模式：</p>
<p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。</p>
<p>20、状态模式：</p>
<p>状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p>
<p>21、访问者模式：</p>
<p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。</p>
<p>若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。</p>
<p>22、中介者模式：</p>
<p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。</p>
<p>如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。</p>
<p>23、解释器模式：</p>
<p>解释器模式一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/23/设计模式/" data-id="cjz3fazyy0005p0fy7rfeh9vg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flex指南" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/flex指南/" class="article-date">
  <time datetime="2019-07-18T07:51:41.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/flex指南/">flex指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>flex,即‘弹性布局’，任何盒模型都可以用</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
</code></pre><p>行内元素也可以使用 Flex 布局</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> inline-flex</span></span>;
}</span>
</code></pre><p>Webkit 内核的浏览器，需要加上<code>-webkit</code>（兼容ios8）</p>
<pre><code><span class="class">.box</span><span class="rules">{
    <span class="rule"><span class="attribute">display</span>:<span class="value"> -webkit-flex</span></span>; <span class="comment">/* Safari */</span>
    <span class="rule"><span class="attribute">display</span>:<span class="value"> flex</span></span>;
}</span>
</code></pre><p>flex有两条轴，分别是主轴（水平轴 main axis）和交叉轴（竖直轴 cross axis）;</p>
<h4 id="容器的属性">容器的属性</h4><p>1) flex-direction 决定主轴的方向</p>
<p>值</p>
<ul>
<li>row // 主轴为水平方向，起点在左端</li>
<li>row-reverse // 主轴为水平方向，起点在右端</li>
<li>column // 主轴为垂直方向，起点在上沿</li>
<li>column-reverse // 主轴为垂直方向，起点在下沿</li>
</ul>
<p>2) flex-warp 如果一条轴线排不下，如何换行</p>
<p>值</p>
<ul>
<li>nowrap // 不换行(默认)</li>
<li>wrap // 换行，第一行在上方</li>
<li>wrap-reverse // 换行，第一行在下方</li>
</ul>
<p>3) flex-flow 属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code></p>
<p>值</p>
<pre><code><span class="class">.box</span> <span class="rules">{
    <span class="rule"><span class="attribute">flex-flow</span>:<span class="value"> &lt;flex-direction&gt; || &lt;flex-wrap&gt;</span></span>;
}</span>
</code></pre><p>4) justify-content 属性定义了项目在主轴上的对齐方式</p>
<p>值</p>
<ul>
<li>flex-start 靠左对齐</li>
<li>flex-end 靠右对齐</li>
<li>center 居中</li>
<li>space-between 均匀的间隔，（两头不留空隙）</li>
<li>space-around 均匀的间隔，两头留空隙，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<p>5) align-items 交叉轴上如何对齐</p>
<p>值</p>
<ul>
<li>flex-start 靠上对齐</li>
<li>flex-end 靠下对齐</li>
<li>center 居中</li>
<li>baseline 项目的第一行文字的基线对齐</li>
<li>stretch （默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<p>6) align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<p>值</p>
<ul>
<li>flex-start 与交叉轴的起点对齐</li>
<li>flex-end 与交叉轴的终点对齐</li>
<li>center 与交叉轴的中点对齐</li>
<li>space-between 与交叉轴两端对齐，轴线之间的间隔平均分布</li>
<li>space-around 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch （默认值）：轴线占满整个交叉轴。</li>
</ul>
<h4 id="项目的属性(里面的item)">项目的属性(里面的item)</h4><p>1) order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0</p>
<pre><code><span class="class">.item</span> <span class="rules">{
    <span class="rule"><span class="attribute">order</span>:<span class="value"> &lt;integer&gt;</span></span>;
}</span>
</code></pre><p>2) flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<p>3) flex-shrink 属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小 （如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。）<br>4) flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小<br>5) flex 属性是flex-grow（元素水平方向在哪，越小越靠前）, flex-shrink （元素等比缩小）和 flex-basis（元素的宽度）的简写，默认值为0 1 auto。后两个属性可选。<br>6) align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/18/flex指南/" data-id="cjz3fb0200041p0fyojmhi0hm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flex/">flex</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-es7-es8-es9-es10新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/es7-es8-es9-es10新特性/" class="article-date">
  <time datetime="2019-07-18T01:33:10.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/es7-es8-es9-es10新特性/">es7,es8,es9,es10新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="es7的新特性：">es7的新特性：</h2><h3 id="新增特性：">新增特性：</h3><p>Array.prototype.includes()<br>**</p>
<h3 id="1)_Array-prototype-includes()">1) Array.prototype.includes()</h3><p>用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<h4 id="参数">参数</h4><p>接收两个参数</p>
<p>1.要搜索的值<br>2.搜索的开始索引</p>
<h4 id="与indexof的区别">与indexof的区别</h4><p>1.返回值不同，indexof返回是值型的，includes返回值是布尔型的<br>2.NaN的判断，如果数组中有NaN，indexof无法判断出来，但是includes可以<br>3.当数组的有空的值的时候，includes会认为空的值是undefined，而indexOf不会</p>
<h3 id="2)_**_求幂运算符">2) ** 求幂运算符</h3><p>可以使用**来替代Math.pow。</p>
<pre><code><span class="number">4</span> ** <span class="number">3</span>  <span class="comment">// 64</span>
Math.<span class="built_in">pow</span>(<span class="number">4</span>,<span class="number">3</span>) <span class="comment">// 64</span>
</code></pre><p>但是，**还支持以下操作</p>
<pre><code>let n = <span class="number">4</span>;
n **= <span class="number">3</span>;
<span class="comment">// 64</span>
</code></pre><h2 id="es8_新特性">es8 新特性</h2><p>主要新功能：</p>
<h3 id="新增特性">新增特性</h3><h4 id="主要特性">主要特性</h4><p>异步函数 Async Functions<br>共享内存和Atomics</p>
<h4 id="次要特性">次要特性</h4><p>Object.values / Object.entries<br>String padding<br>Object.getOwnPropertyDescriptors()<br>函数参数列表和调用中的尾逗号</p>
<h2 id="es9_新特性">es9 新特性</h2><h3 id="新增特性-1">新增特性</h3><h4 id="主要特性-1">主要特性</h4><p>异步迭代<br>Rest/Spread 属性</p>
<h4 id="新的正则表达式功能">新的正则表达式功能</h4><p>RegExp named capture groups<br>RegExp Unicode Property Escapes<br>RegExp Lookbehind Assertions<br>s (dotAll) flag for regular expressions</p>
<h4 id="其他新功能">其他新功能</h4><p>Promise.prototype.finally()<br>模板字符串修改</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://zjzno1.github.io/2019/07/18/es7-es8-es9-es10新特性/" data-id="cjz3fb0240048p0fy9c9gbur2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es/">es</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/新特性/">新特性</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IIFE/">IIFE</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/">MVC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP/">MVP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVVM/">MVVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/app-store/">app store</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apply/">apply</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call/">call</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/express/">express</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/">flex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gulp/">gulp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-博客/">hexo 博客</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-https/">http/https</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ionic/">ionic</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nodejs/">nodejs</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node相关试题/">node相关试题</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prototype/">prototype</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/三角形/">三角形</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件冒泡/">事件冒泡</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件委托/">事件委托</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件捕获/">事件捕获</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/事件绑定/">事件绑定</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前言/">前言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原型-原型链/">原型/原型链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回调函数/">回调函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化相关/">性能优化相关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/收藏/">收藏</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教程/">教程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/文章/">文章</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新特性/">新特性</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/柯里化/">柯里化</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/模型/">模型</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则/">正则</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/水平竖直居中/">水平竖直居中</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深拷贝-浅拷贝/">深拷贝/浅拷贝</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/版本控制/">版本控制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/箭头函数/">箭头函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存/">缓存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络相关/">网络相关</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/规范/">规范</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/调试/">调试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/跨域/">跨域</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题（知识点）总结/">面试题（知识点）总结</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IIFE/" style="font-size: 10px;">IIFE</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/MVP/" style="font-size: 10px;">MVP</a> <a href="/tags/MVVM/" style="font-size: 10px;">MVVM</a> <a href="/tags/app-store/" style="font-size: 10px;">app store</a> <a href="/tags/apply/" style="font-size: 10px;">apply</a> <a href="/tags/call/" style="font-size: 10px;">call</a> <a href="/tags/css/" style="font-size: 17.5px;">css</a> <a href="/tags/es/" style="font-size: 10px;">es</a> <a href="/tags/es6/" style="font-size: 12.5px;">es6</a> <a href="/tags/express/" style="font-size: 10px;">express</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/gulp/" style="font-size: 10px;">gulp</a> <a href="/tags/hexo-博客/" style="font-size: 10px;">hexo 博客</a> <a href="/tags/html/" style="font-size: 12.5px;">html</a> <a href="/tags/http/" style="font-size: 10px;">http</a> <a href="/tags/http-https/" style="font-size: 10px;">http/https</a> <a href="/tags/ionic/" style="font-size: 10px;">ionic</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nodejs/" style="font-size: 12.5px;">nodejs</a> <a href="/tags/node相关试题/" style="font-size: 10px;">node相关试题</a> <a href="/tags/prototype/" style="font-size: 10px;">prototype</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/三角形/" style="font-size: 10px;">三角形</a> <a href="/tags/事件冒泡/" style="font-size: 10px;">事件冒泡</a> <a href="/tags/事件委托/" style="font-size: 10px;">事件委托</a> <a href="/tags/事件捕获/" style="font-size: 10px;">事件捕获</a> <a href="/tags/事件绑定/" style="font-size: 10px;">事件绑定</a> <a href="/tags/前言/" style="font-size: 10px;">前言</a> <a href="/tags/原型-原型链/" style="font-size: 10px;">原型/原型链</a> <a href="/tags/回调函数/" style="font-size: 10px;">回调函数</a> <a href="/tags/性能优化相关/" style="font-size: 10px;">性能优化相关</a> <a href="/tags/收藏/" style="font-size: 10px;">收藏</a> <a href="/tags/教程/" style="font-size: 10px;">教程</a> <a href="/tags/文章/" style="font-size: 10px;">文章</a> <a href="/tags/新特性/" style="font-size: 10px;">新特性</a> <a href="/tags/柯里化/" style="font-size: 10px;">柯里化</a> <a href="/tags/模型/" style="font-size: 10px;">模型</a> <a href="/tags/正则/" style="font-size: 10px;">正则</a> <a href="/tags/水平竖直居中/" style="font-size: 10px;">水平竖直居中</a> <a href="/tags/深拷贝-浅拷贝/" style="font-size: 10px;">深拷贝/浅拷贝</a> <a href="/tags/版本控制/" style="font-size: 10px;">版本控制</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/箭头函数/" style="font-size: 10px;">箭头函数</a> <a href="/tags/缓存/" style="font-size: 10px;">缓存</a> <a href="/tags/网络相关/" style="font-size: 10px;">网络相关</a> <a href="/tags/规范/" style="font-size: 10px;">规范</a> <a href="/tags/设计模式/" style="font-size: 10px;">设计模式</a> <a href="/tags/调试/" style="font-size: 10px;">调试</a> <a href="/tags/跨域/" style="font-size: 10px;">跨域</a> <a href="/tags/面试题（知识点）总结/" style="font-size: 15px;">面试题（知识点）总结</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2116/03/">三月 2116</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2116/03/19/第一篇博客/">第一篇博客</a>
          </li>
        
          <li>
            <a href="/2019/08/07/http缓存详解/">http缓存详解</a>
          </li>
        
          <li>
            <a href="/2019/07/29/js中高级相关问题/">js中高级相关问题</a>
          </li>
        
          <li>
            <a href="/2019/07/23/算法相关/">算法相关</a>
          </li>
        
          <li>
            <a href="/2019/07/23/网络基础相关/">网络基础相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Polar_Space(zjzno1)<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>